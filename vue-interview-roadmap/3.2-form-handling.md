# 3.2 How do you handle forms in Vue?

## Quick Revision
- Use `v-model` for two-way binding on inputs, modifiers for formatting, and custom components for reusable form fields.
- Manage validation with computed rules, watchers, or libraries like Vuelidate, vee-validate, or custom composables.
- Handle submissions by preventing default events, performing async operations, and providing UX feedback (loading, errors).

## Detailed Explanation
### Basic Binding
Vue’s `v-model` syncs input value with reactive state. For checkboxes/radios, use bound arrays or values. Modifiers such as `.lazy` update on `change` events, `.trim` removes whitespace, and `.number` casts to numbers.

### Validation Strategies
Lightweight validation can use computed properties that return error messages and watchers to trigger asynchronous checks. More complex forms benefit from composables that centralize validation logic (`useForm`, `useField`). Popular libraries provide schema-based validation, error collections, and integration with async validators.

### Submission Flow
Handle `@submit.prevent` to stop default browser behavior. Use `async` functions to send requests, set loading states, and reset forms on success. Provide accessible feedback by disabling buttons during submission and announcing errors.

## Code Example
```vue
<template>
  <form @submit.prevent="submit">
    <label>
      Email
      <input v-model.trim="form.email" type="email" />
    </label>
    <span v-if="errors.email">{{ errors.email }}</span>

    <label>
      Password
      <input v-model="form.password" type="password" />
    </label>
    <span v-if="errors.password">{{ errors.password }}</span>

    <button type="submit" :disabled="loading">{{ loading ? 'Signing in…' : 'Sign in' }}</button>
  </form>
</template>

<script setup>
import { reactive, computed, ref } from 'vue';

const form = reactive({ email: '', password: '' });
const loading = ref(false);
const errors = reactive({ email: '', password: '' });

const isValid = computed(() => {
  errors.email = form.email.includes('@') ? '' : 'Email must contain @';
  errors.password = form.password.length >= 8 ? '' : 'Password too short';
  return !errors.email && !errors.password;
});

async function submit() {
  if (!isValid.value) return;
  loading.value = true;
  try {
    await fakeAuth(form);
  } catch (err) {
    errors.password = 'Authentication failed';
  } finally {
    loading.value = false;
  }
}

function fakeAuth({ email }) {
  return new Promise((resolve) => setTimeout(resolve, 600));
}
</script>
```

## Resources
- [Vue.js Docs – Form Input Bindings](https://vuejs.org/guide/essentials/forms.html) – explains `v-model` for each input type.
- [vee-validate Documentation](https://vee-validate.logaretm.com/v4/) – schema-based validation for Vue 3.
- [VueUse – useForm/useField Composables](https://vueuse.org/core/useform/) – utility composables for managing forms and validation.
