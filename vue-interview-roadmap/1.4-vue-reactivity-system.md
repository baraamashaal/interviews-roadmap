# 1.4 How does Vue’s reactivity system work under the hood?

## Quick Revision
- Vue 2 uses getters/setters via `Object.defineProperty`, while Vue 3 uses ES2015 Proxies to intercept operations.
- Reactive getters collect dependencies (effects) in a global stack; setters trigger those effects to re-run.
- Vue tracks dependencies per property using `Dep`/`effect` structures and scheduler queues updates to batch DOM patches.

## Detailed Explanation
### Dependency Tracking
When a component renders, Vue evaluates reactive properties inside a watcher/effect. The currently executing effect is pushed onto a stack. The getter for each accessed property adds that effect to its dependency map (a `Dep` in Vue 2 or a `ReactiveEffect` set in Vue 3). This establishes a many-to-many relationship between state fields and render/update functions.

### Change Detection & Scheduling
When reactive data mutates, the setter notifies all collected effects. Instead of running immediately, effects are queued and flushed asynchronously (next microtask) to batch updates, avoiding redundant re-renders. Computed properties wrap their getter in a lazy effect that caches results until dependencies change.

### Vue 2 vs Vue 3 Implementation
Vue 2 creates a `Observer` per object that converts properties with getters/setters, requiring helpers (`Vue.set`, `Vue.delete`) for new properties. Vue 3 proxies the entire object, allowing detection of property addition, deletion, and iteration (`for...in`, `Object.keys`). Reactive flags (`track`, `trigger`) classify operations (GET, SET, DELETE, ITERATE) to target the right effect sets. Ref values wrap primitives and expose a `.value` getter/setter using the same machinery.

## Code Example
```js
import { reactive, effect } from '@vue/reactivity';

const state = reactive({ count: 0 });

effect(() => {
  console.log(`Count is ${state.count}`);
});

state.count++; // triggers the effect, logging "Count is 1"
```
The `effect` function registers a reactive effect that subscribes to `state.count`. When `count` changes, Vue schedules the effect to run again.

## Resources
- [Vue.js Docs – Reactivity Fundamentals](https://vuejs.org/guide/extras/reactivity-in-depth.html) – deep dive into the Proxy-based system.
- [Vue.js Source – Reactivity Core](https://github.com/vuejs/core/tree/main/packages/reactivity) – reference implementation of `reactive`, `ref`, and `effect`.
- [Vue.js Docs – Computed and Watch](https://vuejs.org/guide/essentials/computed.html) – explains lazy evaluation and dependency tracking with computed properties.
