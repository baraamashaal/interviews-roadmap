# 9.2 What are some techniques for performance optimization in Vue apps?

## Quick Revision
- Optimize rendering with computed properties, memoization, and avoiding unnecessary reactive dependencies.
- Use lazy loading (async components, route-level code splitting) and tree-shaking to reduce bundle size.
- Employ caching (`keep-alive`), virtualization, and performance profiling to handle heavy UI interactions.

## Detailed Explanation
### Rendering Optimizations
Avoid expensive computations inside templates; use computed props. Limit reactive dependencies by destructuring with `toRefs` and splitting components to reduce re-render scope. Use `v-memo` (Vue 3.3+) or `shallowRef` for large objects. Leverage `defineComponent({ inheritAttrs: false })` to avoid attribute updates when unnecessary.

### Network & Bundle
Implement code splitting with dynamic imports and `defineAsyncComponent`. Tree-shake unused components by using ES module imports. Compress assets, enable HTTP/2, and leverage CDN caching. Use `preload`/`prefetch` for critical resources.

### UI Techniques
`<KeepAlive>` caches component instances between route/tab switches. Virtualize long lists with libraries like Vue Virtual Scroll List. Debounce expensive watchers, throttle scroll handlers, and use `requestAnimationFrame` for smooth animations. Profile using browser devtools and Vue DevTools performance timeline.

## Code Example
```vue
<KeepAlive include="Dashboard">
  <component :is="currentView" />
</KeepAlive>
```
Caching the `Dashboard` component avoids re-fetching data each time the user navigates back.

## Resources
- [Vue.js Docs – Performance](https://vuejs.org/guide/best-practices/performance.html) – official performance checklist.
- [Vue.js Docs – KeepAlive](https://vuejs.org/api/built-in-components.html#keepalive) – caching component instances.
- [VueUse – useVirtualList](https://vueuse.org/core/usevirtuallist/) – helper for list virtualization.
