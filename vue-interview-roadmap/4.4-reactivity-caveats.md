# 4.4 What are some reactivity caveats in Vue (like array/object changes in Vue 2)?

## Quick Revision
- Vue 2 cannot detect property addition/deletion or index-based array mutations without helpers; Vue 3 resolves this with Proxies.
- Use `Vue.set`/`this.$set` and `Vue.delete` in Vue 2 to ensure new properties are reactive, or array methods like `splice`.
- In Vue 3, prefer `reactive`/`ref` and avoid mutating raw objects returned from `toRaw`; use `markRaw` for opt-outs.

## Detailed Explanation
### Vue 2 Limitations
Because Vue 2 proxies each property using `Object.defineProperty`, it can’t intercept property additions. Adding `obj.newProp = 1` won’t trigger updates. Similarly, setting `arr[index] = value` won’t be reactive. Use `Vue.set(obj, 'newProp', value)` or `this.$set` to define reactive getters/setters. For arrays, prefer methods like `splice`, `push`, or `shift`, which Vue intercepts.

### Vue 3 Improvements
Vue 3’s Proxy-based system tracks operations like `set`, `deleteProperty`, and `has`. Property additions and deletions are reactive. However, some caveats remain: using `toRaw` to bypass reactivity requires manual updates, and storing non-reactive libraries might need `markRaw` to prevent deep proxying. When destructuring reactive objects, you may lose reactivity unless you convert to refs (`toRefs`).

### Best Practices
Avoid mutating reactive objects outside Vue’s reactivity (e.g., by reassigning `state = newObj` inside `setup`). For arrays, rely on `push`, `splice`, or `arr[index] = value` (works in Vue 3). In Vue 2 legacy projects, document usage of `Vue.set` and avoid replacing entire reactive objects without using `Object.assign` to keep references.

## Code Example
```js
// Vue 2 example
data() {
  return { user: { name: 'Evan' }, tags: ['vue'] };
},
mounted() {
  this.$set(this.user, 'role', 'maintainer'); // reactive addition
  this.tags.splice(1, 0, 'frontend');
}
```

## Resources
- [Vue 2 Docs – Reactivity Caveats](https://v2.vuejs.org/v2/guide/reactivity.html#Change-Detection-Caveats) – legacy guidance on arrays/objects.
- [Vue 3 Docs – Reactivity in Depth](https://vuejs.org/guide/extras/reactivity-in-depth.html) – explains Proxy traps and caveats.
- [Vue.js Docs – toRef and toRefs](https://vuejs.org/api/reactivity-utilities.html#toref) – avoiding reactivity loss when destructuring.
