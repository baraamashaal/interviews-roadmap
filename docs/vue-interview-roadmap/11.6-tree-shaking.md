# 11.6 What is tree-shaking in Vue 3 and how does it improve performance?

## Quick Revision
- Tree-shaking removes unused code from the bundle during build, reducing payload size.
- Vue 3’s modular architecture exposes ES modules so bundlers can drop unused APIs (`ref`, `watch`, etc.).
- Combine tree-shaking with component-level code splitting and proper imports to minimize shipped code.

## Detailed Explanation
### Modular Core
Vue 3 reorganized the core into packages (`@vue/runtime-core`, `@vue/reactivity`, etc.) with named exports. When you import only what you need, bundlers (Rollup, esbuild) can statically analyze imports and eliminate unused exports.

### Best Practices
Avoid importing the entire Vue object (`import Vue from 'vue'`). Instead, use named imports (`import { ref } from 'vue'`). Ensure bundler config is in production mode with minification and dead-code elimination enabled. For libraries, offer ESM builds with side-effect-free modules to enable tree-shaking.

### Impact
Smaller bundles mean faster load times and better performance. Tree-shaking also enables partial builds (e.g., using only the reactivity package without the DOM runtime). Combined with `vite` or Rollup, Vue apps benefit from significant size reductions compared to Vue 2 builds.

## Code Example
```js
// Good: tree-shakable
import { createApp, ref } from 'vue';

// Bad: prevents tree-shaking in some bundlers
// import * as Vue from 'vue';
```

## Resources
- [Vue.js Docs – Tree-shaking Support](https://vuejs.org/guide/extras/ways-of-using-vue.html#bundler-build) – notes on ESM builds and bundlers.
- [Vite Documentation – Dependency Pre-Bundling](https://vitejs.dev/guide/dep-pre-bundling.html) – how Vite handles tree-shaking.
- [Rollup Tree-Shaking Guide](https://rollupjs.org/introduction/#tree-shaking) – underlying concepts used by Vue tooling.
