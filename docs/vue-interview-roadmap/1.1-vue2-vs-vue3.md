# 1.1 What are the main differences between Vue 2 and Vue 3?

## Quick Revision
- Vue 3 replaces the Object.defineProperty-based reactivity of Vue 2 with ES2015 Proxies, enabling deep reactivity, better performance, and tracking of property additions/deletions.
- The Composition API augments the Options API by grouping logic by feature, improving reuse and TypeScript support.
- Vue 3 ships a smaller runtime with tree-shaking, rewritten compiler, Fragments, Teleport, Suspense, and improved server-side rendering.

## Detailed Explanation
### Reactivity & Rendering
Vue 2 relies on `Object.defineProperty` to convert component data into getters/setters, which cannot intercept property additions and struggles with array index changes. Vue 3 rewrites this layer using ES2015 `Proxy`, giving deep reactivity for nested structures and eliminating the need for workarounds like `Vue.set`. The virtual DOM renderer was reimplemented with a compiler-informed runtime, resulting in faster updates and support for multiple root nodes (Fragments).

### APIs & TypeScript
While Vue 2 centers on the Options API (`data`, `methods`, `computed`), Vue 3 introduces the Composition API (`setup`, `ref`, `reactive`, `computed`) so you can compose logic functions and reuse them across components. TypeScript support is first-class through better typings, script setup, and Volar integration. Migration helpers ensure Options API continues to work.

### Advanced Features & Tooling
Vue 3 adds `Teleport` for rendering elements outside component hierarchies, `Suspense` for async component loading, and better tree-shaking via ES modules. Tooling moved to Vite-based scaffolding (`create-vue`), replacing the older webpack-centric Vue CLI defaults. Server-side rendering was rebuilt on top of the new runtime for streaming and hydration improvements.

## Code Example
```vue
<!-- Vue 3 Composition API example -->
<script setup>
import { ref, computed } from 'vue';

const count = ref(0);
const double = computed(() => count.value * 2);
function increment() {
  count.value++;
}
</script>

<template>
  <button @click="increment">{{ count }} → {{ double }}</button>
</template>
```
The same component in Vue 2 would require the Options API and `data()`, `computed`, `methods`, illustrating the ergonomic improvements in Vue 3 for co-locating related logic.

## Resources
- [Vue.js Docs – Migration from Vue 2 to Vue 3](https://v3-migration.vuejs.org/) – official migration guide outlining runtime changes and new APIs.
- [Vue.js Docs – Composition API](https://vuejs.org/guide/extras/composition-api-faq.html) – explains benefits over Options API with examples.
- [Vue RFC 0042 – Function-based API](https://github.com/vuejs/rfcs/pull/42) – design rationale behind the Composition API and Proxy-based reactivity.
