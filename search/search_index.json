{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Front-End Interview Roadmap","text":"<p>Welcome! This site gathers concise study notes and curated resources to help you prepare for modern front-end interviews. While the first module spotlights Vue, the plan is to steadily expand into framework-agnostic fundamentals and other ecosystems (React, Angular, performance engineering, accessibility, and more).</p>"},{"location":"#what-youll-find-here","title":"What you'll find here","text":"<ul> <li>Concept summaries: Digestible explanations of core browser, JavaScript, and framework topics.</li> <li>Interview preparation tracks: Step-by-step outlines to review concepts, practice exercises, and whiteboard prompts.</li> <li>Reference checklists: Quick reminders for common pitfalls, optimization tips, and best practices.</li> </ul>"},{"location":"#how-to-use-this-guide","title":"How to use this guide","text":"<ol> <li>Start with the roadmap that matches your immediate goals.</li> <li>Use the provided checklists to self-assess and identify knowledge gaps.</li> <li>Extend the notes with your own examples or links to articles and documentation.</li> </ol>"},{"location":"#current-focus-vue","title":"Current focus: Vue","text":"<ul> <li>\ud83d\udcd8 Dive into the foundational module: Vue Interview Roadmap</li> <li>\ud83d\udd01 Revisit this page for updates as more front-end areas are added.</li> </ul> <p>Last updated: 2025-02-14</p>"},{"location":"vue-interview-roadmap/","title":"Vue Interview Roadmap (Basic \u2192 Intermediate \u2192 Advanced)","text":"<p>Last updated: 2025-09-28</p> <p>\u2705 Each question now has a dedicated, in-depth answer file inside <code>/vue-interview-roadmap</code>. Every answer includes: - A Quick Revision section for rapid study. - A Detailed Explanation with terminology, comparisons, and best practices. - Code examples illustrating the concept. - A curated Resources list citing the references used.</p> <p>Use the index below as your navigation hub and progress checklist.</p>"},{"location":"vue-interview-roadmap/#basic-vue-questions","title":"\ud83c\udf31 Basic Vue Questions","text":"<p>1. Vue Fundamentals - 1.1 What are the main differences between Vue 2 and Vue 3? - 1.2 Can you explain the difference between the Options API and the Composition API? - 1.3 Walk me through the Vue lifecycle hooks. Which ones are most commonly used? - 1.4 How does Vue\u2019s reactivity system work under the hood? - 1.5 What are the key differences between v-if and v-show?</p> <p>2. Directives &amp; Components - 2.1 Can you explain the role of directives like v-bind, v-model, and v-for? - 2.2 What are Single File Components (SFCs) and why are they useful?</p> <p>3. Reactivity &amp; Forms - 3.1 How do computed properties differ from watchers? - 3.2 How do you handle forms in Vue?</p>"},{"location":"vue-interview-roadmap/#intermediate-vue-questions","title":"\ud83c\udf3f Intermediate Vue Questions","text":"<p>4. State Management - 4.1 What are the basics of Vuex and how does it differ from local component state? - 4.2 How do mixins differ from the Composition API? - 4.3 Compare Vuex with Redux. What are their strengths and weaknesses? - 4.4 What are some reactivity caveats in Vue (like array/object changes in Vue 2)?</p> <p>5. Routing &amp; Navigation - 5.1 How do Vue Router navigation guards work? - 5.2 What\u2019s the difference between beforeEach, beforeEnter, and beforeRouteLeave guards?</p> <p>6. Components &amp; Composition - 6.1 How do you create and use async components in Vue? - 6.2 What are the basics of the Vue CLI? - 6.3 What is the purpose of the setup() function in Vue 3? - 6.4 Can you explain slots, scoped slots, and dynamic slots? - 6.5 How does scoped CSS work in Vue? - 6.6 What is Teleport in Vue 3 and when would you use it? - 6.7 How does the Provide/Inject API work? - 6.8 How can you create custom directives in Vue?</p> <p>7. Debugging &amp; Testing - 7.1 How do you handle error boundaries in Vue? - 7.2 What tools does Vue DevTools provide for debugging? - 7.3 What are some common Vue testing strategies (unit testing, integration testing, snapshot testing)?</p> <p>8. Animations &amp; UI Enhancements - 8.1 How do Vue transitions and animations work?</p>"},{"location":"vue-interview-roadmap/#advanced-vue-questions","title":"\ud83c\udf33 Advanced Vue Questions","text":"<p>9. Performance &amp; Optimization - 9.1 How does Vue handle DOM updates with its virtual DOM? - 9.2 What are some techniques for performance optimization in Vue apps? - 9.3 What are common memory leaks in Vue and how do you avoid them?</p> <p>10. SSR &amp; Ecosystem - 10.1 What is Vue SSR and how does Nuxt.js help with server-side rendering? - 10.2 Explain hydration in Vue SSR. - 10.3 What are the differences between SPA, SSR, and SSG in Vue apps? - 10.4 How do you handle internationalization in Vue (vue-i18n)?</p> <p>11. Advanced Project Practices - 11.1 How do you manage code splitting and lazy loading in Vue? - 11.2 What are Composition API best practices for scaling large projects? - 11.3 How do you integrate TypeScript with Vue 3? - 11.4 How do suspense and async setup work in Vue 3? - 11.5 Explain how Vue handles concurrent rendering and async updates. - 11.6 What is tree-shaking in Vue 3 and how does it improve performance?</p>"},{"location":"vue-interview-roadmap/#tips","title":"\u2705 Tips","text":"<ul> <li>Treat numbers as IDs (e.g., \u201cLet\u2019s drill into 6.3 next\u201d).</li> <li>Mark questions as complete in your notes after reviewing their dedicated file.</li> <li>Extend the folder with your own notes or follow-up questions to personalize your study path.</li> </ul>"},{"location":"vue-interview-roadmap/1.1-vue2-vs-vue3/","title":"1.1 What are the main differences between Vue 2 and Vue 3?","text":""},{"location":"vue-interview-roadmap/1.1-vue2-vs-vue3/#quick-revision","title":"Quick Revision","text":"<ul> <li>Vue 3 replaces the Object.defineProperty-based reactivity of Vue 2 with ES2015 Proxies, enabling deep reactivity, better performance, and tracking of property additions/deletions.</li> <li>The Composition API augments the Options API by grouping logic by feature, improving reuse and TypeScript support.</li> <li>Vue 3 ships a smaller runtime with tree-shaking, rewritten compiler, Fragments, Teleport, Suspense, and improved server-side rendering.</li> </ul>"},{"location":"vue-interview-roadmap/1.1-vue2-vs-vue3/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/1.1-vue2-vs-vue3/#reactivity-rendering","title":"Reactivity &amp; Rendering","text":"<p>Vue 2 relies on <code>Object.defineProperty</code> to convert component data into getters/setters, which cannot intercept property additions and struggles with array index changes. Vue 3 rewrites this layer using ES2015 <code>Proxy</code>, giving deep reactivity for nested structures and eliminating the need for workarounds like <code>Vue.set</code>. The virtual DOM renderer was reimplemented with a compiler-informed runtime, resulting in faster updates and support for multiple root nodes (Fragments).</p>"},{"location":"vue-interview-roadmap/1.1-vue2-vs-vue3/#apis-typescript","title":"APIs &amp; TypeScript","text":"<p>While Vue 2 centers on the Options API (<code>data</code>, <code>methods</code>, <code>computed</code>), Vue 3 introduces the Composition API (<code>setup</code>, <code>ref</code>, <code>reactive</code>, <code>computed</code>) so you can compose logic functions and reuse them across components. TypeScript support is first-class through better typings, script setup, and Volar integration. Migration helpers ensure Options API continues to work.</p>"},{"location":"vue-interview-roadmap/1.1-vue2-vs-vue3/#advanced-features-tooling","title":"Advanced Features &amp; Tooling","text":"<p>Vue 3 adds <code>Teleport</code> for rendering elements outside component hierarchies, <code>Suspense</code> for async component loading, and better tree-shaking via ES modules. Tooling moved to Vite-based scaffolding (<code>create-vue</code>), replacing the older webpack-centric Vue CLI defaults. Server-side rendering was rebuilt on top of the new runtime for streaming and hydration improvements.</p>"},{"location":"vue-interview-roadmap/1.1-vue2-vs-vue3/#code-example","title":"Code Example","text":"<p><pre><code>&lt;!-- Vue 3 Composition API example --&gt;\n&lt;script setup&gt;\nimport { ref, computed } from 'vue';\n\nconst count = ref(0);\nconst double = computed(() =&gt; count.value * 2);\nfunction increment() {\n  count.value++;\n}\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;button @click=\"increment\"&gt;{{ count }} \u2192 {{ double }}&lt;/button&gt;\n&lt;/template&gt;\n</code></pre> The same component in Vue 2 would require the Options API and <code>data()</code>, <code>computed</code>, <code>methods</code>, illustrating the ergonomic improvements in Vue 3 for co-locating related logic.</p>"},{"location":"vue-interview-roadmap/1.1-vue2-vs-vue3/#resources","title":"Resources","text":"<ul> <li>Vue.js Docs \u2013 Migration from Vue 2 to Vue 3 \u2013 official migration guide outlining runtime changes and new APIs.</li> <li>Vue.js Docs \u2013 Composition API \u2013 explains benefits over Options API with examples.</li> <li>Vue RFC 0042 \u2013 Function-based API \u2013 design rationale behind the Composition API and Proxy-based reactivity.</li> </ul>"},{"location":"vue-interview-roadmap/1.2-options-vs-composition-api/","title":"1.2 Can you explain the difference between the Options API and the Composition API?","text":""},{"location":"vue-interview-roadmap/1.2-options-vs-composition-api/#quick-revision","title":"Quick Revision","text":"<ul> <li>Options API organizes component logic by option (<code>data</code>, <code>methods</code>, <code>computed</code>), which can scatter related functionality across sections.</li> <li>Composition API uses the <code>setup()</code> function with <code>ref</code>, <code>reactive</code>, and composables to group logic by feature and improve reuse.</li> <li>Composition API unlocks better TypeScript inference, logic extraction, and sharing without mixins, while Options API remains simpler for small components.</li> </ul>"},{"location":"vue-interview-roadmap/1.2-options-vs-composition-api/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/1.2-options-vs-composition-api/#options-api-characteristics","title":"Options API Characteristics","text":"<p>In the Options API, you declare component state and behavior inside a configuration object. Vue merges options at runtime, providing clear lifecycle hooks (<code>created</code>, <code>mounted</code>) and automatic <code>this</code> binding. This approach is approachable and works well for small components. However, as components grow, related logic (e.g., authentication) ends up split between <code>data</code>, <code>computed</code>, <code>watch</code>, and <code>methods</code>, making refactoring and reuse harder.</p>"},{"location":"vue-interview-roadmap/1.2-options-vs-composition-api/#composition-api-characteristics","title":"Composition API Characteristics","text":"<p>The Composition API exposes a <code>setup(props, context)</code> function that runs before component creation. You create reactive state with <code>ref</code> or <code>reactive</code>, derive values with <code>computed</code>, and expose features by returning them. Logic can be extracted to plain functions (composables) that return reactive primitives, avoiding the global namespace collisions of mixins. Types are easier to express, and code splitting by feature improves readability.</p>"},{"location":"vue-interview-roadmap/1.2-options-vs-composition-api/#choosing-between-them","title":"Choosing Between Them","text":"<p>Use the Options API for smaller components or teams that prefer declarative structure. Choose Composition API when you need to reuse logic, share stateful utilities, or leverage advanced TypeScript. Both APIs can coexist, and the <code>&lt;script setup&gt;</code> SFC syntax reduces boilerplate for Composition API code.</p>"},{"location":"vue-interview-roadmap/1.2-options-vs-composition-api/#code-example","title":"Code Example","text":"<pre><code>&lt;!-- Options API --&gt;\n&lt;script&gt;\nexport default {\n  data() {\n    return { count: 0 };\n  },\n  computed: {\n    double() {\n      return this.count * 2;\n    },\n  },\n  methods: {\n    increment() {\n      this.count++;\n    },\n  },\n};\n&lt;/script&gt;\n\n&lt;!-- Composition API with &lt;script setup&gt; --&gt;\n&lt;script setup&gt;\nimport { ref, computed } from 'vue';\n\nconst count = ref(0);\nconst double = computed(() =&gt; count.value * 2);\nconst increment = () =&gt; count.value++;\n&lt;/script&gt;\n</code></pre>"},{"location":"vue-interview-roadmap/1.2-options-vs-composition-api/#resources","title":"Resources","text":"<ul> <li>Vue.js Docs \u2013 Options API \u2013 official overview of the Options syntax.</li> <li>Vue.js Docs \u2013 Composition API \u2013 introduces setup and composables with examples.</li> <li>Vue.js Docs \u2013 Reusability with Composables \u2013 demonstrates logic extraction patterns unique to the Composition API.</li> </ul>"},{"location":"vue-interview-roadmap/1.3-vue-lifecycle-hooks/","title":"1.3 Walk me through the Vue lifecycle hooks. Which ones are most commonly used?","text":""},{"location":"vue-interview-roadmap/1.3-vue-lifecycle-hooks/#quick-revision","title":"Quick Revision","text":"<ul> <li>Lifecycle hooks fire during component creation, mounting, updating, and unmounting.</li> <li>Common hooks: <code>onMounted</code>/<code>mounted</code> for DOM access, <code>onBeforeUnmount</code>/<code>beforeDestroy</code> for cleanup, <code>onUpdated</code>/<code>updated</code> for reacting to DOM updates.</li> <li>Vue 3 exposes lifecycle hooks inside <code>setup()</code> via <code>onX</code> helpers (e.g., <code>onMounted</code>), maintaining parity with Options API equivalents.</li> </ul>"},{"location":"vue-interview-roadmap/1.3-vue-lifecycle-hooks/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/1.3-vue-lifecycle-hooks/#creation-phase","title":"Creation Phase","text":"<p>In Vue 2 Options API, <code>beforeCreate</code> and <code>created</code> run before the component is mounted. <code>created</code> is often used for initial data fetching because reactivity is ready but the DOM is not. In Vue 3 Composition API, this logic typically lives directly in <code>setup()</code>.</p>"},{"location":"vue-interview-roadmap/1.3-vue-lifecycle-hooks/#mounting-phase","title":"Mounting Phase","text":"<p><code>beforeMount</code> executes right before the initial render. <code>mounted</code> (or <code>onMounted</code> in Composition API) runs after the component\u2019s template has been rendered and inserted into the DOM. It is ideal for interacting with DOM APIs, third-party libraries, or measurements.</p>"},{"location":"vue-interview-roadmap/1.3-vue-lifecycle-hooks/#update-phase","title":"Update Phase","text":"<p>When reactive state changes, <code>beforeUpdate</code> triggers before the DOM patch, while <code>updated</code> fires after the DOM is updated. Use <code>watch</code> or computed props for most state reactions; reserve <code>updated</code> for DOM-dependent side effects.</p>"},{"location":"vue-interview-roadmap/1.3-vue-lifecycle-hooks/#unmounting-phase","title":"Unmounting Phase","text":"<p><code>beforeUnmount</code> (<code>beforeDestroy</code> in Vue 2) runs before the component is removed. <code>unmounted</code> (<code>destroyed</code>) executes after teardown. They are crucial for removing event listeners, canceling network requests, or cleaning intervals. In Composition API, use <code>onBeforeUnmount</code> and <code>onUnmounted</code> helpers.</p>"},{"location":"vue-interview-roadmap/1.3-vue-lifecycle-hooks/#error-handling-suspense","title":"Error Handling &amp; Suspense","text":"<p>Vue 2.5+ adds <code>errorCaptured</code> to catch errors from child components. Vue 3 also exposes <code>onErrorCaptured</code>. Suspense components provide <code>onServerPrefetch</code> for SSR data fetching. Keep cleanup in <code>onBeforeUnmount</code> to avoid leaks.</p>"},{"location":"vue-interview-roadmap/1.3-vue-lifecycle-hooks/#code-example","title":"Code Example","text":"<pre><code>&lt;script setup&gt;\nimport { onMounted, onBeforeUnmount, ref } from 'vue';\n\nconst width = ref(window.innerWidth);\n\nfunction updateWidth() {\n  width.value = window.innerWidth;\n}\n\nonMounted(() =&gt; {\n  window.addEventListener('resize', updateWidth);\n});\n\nonBeforeUnmount(() =&gt; {\n  window.removeEventListener('resize', updateWidth);\n});\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;p&gt;Viewport width: {{ width }}px&lt;/p&gt;\n&lt;/template&gt;\n</code></pre>"},{"location":"vue-interview-roadmap/1.3-vue-lifecycle-hooks/#resources","title":"Resources","text":"<ul> <li>Vue.js Docs \u2013 Lifecycle Diagram \u2013 official overview of lifecycle phases and hooks.</li> <li>Vue.js Docs \u2013 Composition API Lifecycle Hooks \u2013 explains <code>onMounted</code>, <code>onUpdated</code>, etc.</li> <li>Vue.js Docs \u2013 Handling Errors \u2013 covers <code>errorCaptured</code> and error boundaries.</li> </ul>"},{"location":"vue-interview-roadmap/1.4-vue-reactivity-system/","title":"1.4 How does Vue\u2019s reactivity system work under the hood?","text":""},{"location":"vue-interview-roadmap/1.4-vue-reactivity-system/#quick-revision","title":"Quick Revision","text":"<ul> <li>Vue 2 uses getters/setters via <code>Object.defineProperty</code>, while Vue 3 uses ES2015 Proxies to intercept operations.</li> <li>Reactive getters collect dependencies (effects) in a global stack; setters trigger those effects to re-run.</li> <li>Vue tracks dependencies per property using <code>Dep</code>/<code>effect</code> structures and scheduler queues updates to batch DOM patches.</li> </ul>"},{"location":"vue-interview-roadmap/1.4-vue-reactivity-system/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/1.4-vue-reactivity-system/#dependency-tracking","title":"Dependency Tracking","text":"<p>When a component renders, Vue evaluates reactive properties inside a watcher/effect. The currently executing effect is pushed onto a stack. The getter for each accessed property adds that effect to its dependency map (a <code>Dep</code> in Vue 2 or a <code>ReactiveEffect</code> set in Vue 3). This establishes a many-to-many relationship between state fields and render/update functions.</p>"},{"location":"vue-interview-roadmap/1.4-vue-reactivity-system/#change-detection-scheduling","title":"Change Detection &amp; Scheduling","text":"<p>When reactive data mutates, the setter notifies all collected effects. Instead of running immediately, effects are queued and flushed asynchronously (next microtask) to batch updates, avoiding redundant re-renders. Computed properties wrap their getter in a lazy effect that caches results until dependencies change.</p>"},{"location":"vue-interview-roadmap/1.4-vue-reactivity-system/#vue-2-vs-vue-3-implementation","title":"Vue 2 vs Vue 3 Implementation","text":"<p>Vue 2 creates a <code>Observer</code> per object that converts properties with getters/setters, requiring helpers (<code>Vue.set</code>, <code>Vue.delete</code>) for new properties. Vue 3 proxies the entire object, allowing detection of property addition, deletion, and iteration (<code>for...in</code>, <code>Object.keys</code>). Reactive flags (<code>track</code>, <code>trigger</code>) classify operations (GET, SET, DELETE, ITERATE) to target the right effect sets. Ref values wrap primitives and expose a <code>.value</code> getter/setter using the same machinery.</p>"},{"location":"vue-interview-roadmap/1.4-vue-reactivity-system/#code-example","title":"Code Example","text":"<p><pre><code>import { reactive, effect } from '@vue/reactivity';\n\nconst state = reactive({ count: 0 });\n\neffect(() =&gt; {\n  console.log(`Count is ${state.count}`);\n});\n\nstate.count++; // triggers the effect, logging \"Count is 1\"\n</code></pre> The <code>effect</code> function registers a reactive effect that subscribes to <code>state.count</code>. When <code>count</code> changes, Vue schedules the effect to run again.</p>"},{"location":"vue-interview-roadmap/1.4-vue-reactivity-system/#resources","title":"Resources","text":"<ul> <li>Vue.js Docs \u2013 Reactivity Fundamentals \u2013 deep dive into the Proxy-based system.</li> <li>Vue.js Source \u2013 Reactivity Core \u2013 reference implementation of <code>reactive</code>, <code>ref</code>, and <code>effect</code>.</li> <li>Vue.js Docs \u2013 Computed and Watch \u2013 explains lazy evaluation and dependency tracking with computed properties.</li> </ul>"},{"location":"vue-interview-roadmap/1.5-v-if-vs-v-show/","title":"1.5 What are the key differences between v-if and v-show?","text":""},{"location":"vue-interview-roadmap/1.5-v-if-vs-v-show/#quick-revision","title":"Quick Revision","text":"<ul> <li><code>v-if</code> conditionally renders elements, adding/removing them from the DOM; <code>v-show</code> toggles the <code>display</code> CSS property.</li> <li><code>v-if</code> has higher toggle cost but no initial render cost when false; <code>v-show</code> always renders once but toggles cheaply.</li> <li>Use <code>v-if</code> for infrequent conditional content (e.g., modal), <code>v-show</code> for frequent toggling (e.g., tabs).</li> </ul>"},{"location":"vue-interview-roadmap/1.5-v-if-vs-v-show/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/1.5-v-if-vs-v-show/#rendering-behavior","title":"Rendering Behavior","text":"<p><code>v-if</code> controls whether Vue creates or destroys a component subtree. When the condition is false, Vue removes listeners, child components, and DOM nodes. This saves initial work when the condition is rarely true but incurs a cost each toggle. <code>v-show</code> renders the element once and simply sets <code>display: none</code> when false, preserving the DOM structure and component state.</p>"},{"location":"vue-interview-roadmap/1.5-v-if-vs-v-show/#performance-considerations","title":"Performance Considerations","text":"<p><code>v-if</code> lazily evaluates the branch, so expensive components are skipped entirely until needed. However, toggling often can hurt performance due to repeated mounting/unmounting. <code>v-show</code> guarantees a one-time render cost and constant-time toggling, ideal for frequently shown/hidden elements where initial render cost is acceptable.</p>"},{"location":"vue-interview-roadmap/1.5-v-if-vs-v-show/#side-effects-accessibility","title":"Side Effects &amp; Accessibility","text":"<p>Because <code>v-show</code> keeps elements in the DOM, focus, component state, and watchers remain active even when hidden\u2014useful for cached forms but potentially problematic for accessibility if hidden elements remain focusable. With <code>v-if</code>, watchers and child lifecycle hooks fire each time the branch is toggled.</p>"},{"location":"vue-interview-roadmap/1.5-v-if-vs-v-show/#code-example","title":"Code Example","text":"<pre><code>&lt;template&gt;\n  &lt;button @click=\"show = !show\"&gt;Toggle&lt;/button&gt;\n\n  &lt;HeavyChart v-if=\"show\" /&gt;\n  &lt;p v-show=\"show\"&gt;This text toggles display only.&lt;/p&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { ref } from 'vue';\nimport HeavyChart from './HeavyChart.vue';\n\nconst show = ref(false);\n&lt;/script&gt;\n</code></pre>"},{"location":"vue-interview-roadmap/1.5-v-if-vs-v-show/#resources","title":"Resources","text":"<ul> <li>Vue.js Docs \u2013 Conditional Rendering \u2013 official explanation of <code>v-if</code> and <code>v-show</code> differences.</li> <li>Vue.js Style Guide \u2013 Avoid v-if with v-for \u2013 related performance considerations.</li> <li>Vue School \u2013 Vue Conditional Rendering Guide \u2013 practical tips on when to use each directive.</li> </ul>"},{"location":"vue-interview-roadmap/10.1-vue-ssr-nuxt/","title":"10.1 What is Vue SSR and how does Nuxt.js help with server-side rendering?","text":""},{"location":"vue-interview-roadmap/10.1-vue-ssr-nuxt/#quick-revision","title":"Quick Revision","text":"<ul> <li>Vue SSR renders components to HTML on the server, improving perceived performance and SEO.</li> <li>The Vue SSR API (<code>@vue/server-renderer</code>) turns Vue apps into server-rendered HTML with hydration on the client.</li> <li>Nuxt.js provides a higher-level framework for SSR/SSG, handling routing, data fetching, and deployment optimizations.</li> </ul>"},{"location":"vue-interview-roadmap/10.1-vue-ssr-nuxt/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/10.1-vue-ssr-nuxt/#vue-ssr-basics","title":"Vue SSR Basics","text":"<p>Server-side rendering involves running Vue components on the server to produce HTML, sending it to the client, and hydrating it with client-side JavaScript. Vue\u2019s SSR renderer serializes the app tree with current state. Hydration attaches event listeners and reuses DOM instead of re-rendering.</p>"},{"location":"vue-interview-roadmap/10.1-vue-ssr-nuxt/#challenges-solutions","title":"Challenges &amp; Solutions","text":"<p>SSR requires handling async data fetching, managing per-request state, and ensuring deterministic output. You must avoid browser-only APIs during server render. Caching rendered pages and streaming can improve performance.</p>"},{"location":"vue-interview-roadmap/10.1-vue-ssr-nuxt/#nuxtjs-advantages","title":"Nuxt.js Advantages","text":"<p>Nuxt builds on Vue SSR by providing file-based routing, data fetching hooks (<code>asyncData</code>, <code>useFetch</code>), automatic code splitting, and deployment presets (SSR, SSG, Hybrid). It abstracts SSR boilerplate, offers modules (auth, i18n), and optimizes bundling via Nitro server.</p>"},{"location":"vue-interview-roadmap/10.1-vue-ssr-nuxt/#code-example","title":"Code Example","text":"<pre><code>// server.js\nimport { createSSRApp } from 'vue';\nimport { renderToString } from '@vue/server-renderer';\nimport App from './App.vue';\n\nconst app = createSSRApp(App);\nconst html = await renderToString(app);\n</code></pre>"},{"location":"vue-interview-roadmap/10.1-vue-ssr-nuxt/#resources","title":"Resources","text":"<ul> <li>Vue.js Docs \u2013 Server-Side Rendering \u2013 official SSR guide.</li> <li>Nuxt 3 Documentation \u2013 features for SSR, SSG, and hybrid rendering.</li> <li>Vue SSR Guide \u2013 Hydration \u2013 explains hydration lifecycle.</li> </ul>"},{"location":"vue-interview-roadmap/10.2-hydration/","title":"10.2 Explain hydration in Vue SSR.","text":""},{"location":"vue-interview-roadmap/10.2-hydration/#quick-revision","title":"Quick Revision","text":"<ul> <li>Hydration attaches Vue\u2019s runtime to server-rendered HTML, reusing markup instead of re-rendering from scratch.</li> <li>Vue compares server-rendered DOM with client-side virtual DOM; mismatches trigger warnings and full re-render of the subtree.</li> <li>Proper hydration requires deterministic markup and avoiding browser-only APIs during server rendering.</li> </ul>"},{"location":"vue-interview-roadmap/10.2-hydration/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/10.2-hydration/#hydration-flow","title":"Hydration Flow","text":"<p>After SSR sends HTML, the client downloads the JavaScript bundle. Vue creates a virtual DOM tree and walks the existing DOM to attach event listeners and reactive bindings. As long as the DOM matches expectations, Vue reuses nodes, leading to fast interactive startup.</p>"},{"location":"vue-interview-roadmap/10.2-hydration/#handling-mismatches","title":"Handling Mismatches","text":"<p>If server and client render different DOM (e.g., using <code>Date.now()</code>), Vue logs hydration mismatch warnings and falls back to client rendering for that subtree. Use deterministic data, or gate browser-only logic behind <code>onMounted</code> or <code>process.client</code> checks in Nuxt.</p>"},{"location":"vue-interview-roadmap/10.2-hydration/#streaming-suspense","title":"Streaming &amp; Suspense","text":"<p>Vue 3 SSR supports streaming and Suspense, which delay hydration for async components until data resolves. On the client, hydration occurs when the async content is available, ensuring consistent markup.</p>"},{"location":"vue-interview-roadmap/10.2-hydration/#code-example","title":"Code Example","text":"<pre><code>// SSR entry\nexport async function render(url) {\n  const app = createApp(App);\n  const html = await renderToString(app);\n  return html;\n}\n\n// Client entry\nconst app = createApp(App);\napp.mount('#app'); // hydrates existing markup\n</code></pre>"},{"location":"vue-interview-roadmap/10.2-hydration/#resources","title":"Resources","text":"<ul> <li>Vue.js Docs \u2013 Hydration \u2013 official explanation of hydration process.</li> <li>Nuxt 3 Docs \u2013 Rendering \u2013 describes hydration in hybrid rendering.</li> <li>Vue SSR Guide \u2013 Mismatch Handling \u2013 how Vue resolves DOM mismatches.</li> </ul>"},{"location":"vue-interview-roadmap/10.3-spa-ssr-ssg/","title":"10.3 What are the differences between SPA, SSR, and SSG in Vue apps?","text":""},{"location":"vue-interview-roadmap/10.3-spa-ssr-ssg/#quick-revision","title":"Quick Revision","text":"<ul> <li>SPA (Single Page Application) renders entirely on the client after initial bundle load; fastest builds but slower first render.</li> <li>SSR (Server-Side Rendering) renders HTML per request on the server, improving first paint and SEO with dynamic content.</li> <li>SSG (Static Site Generation) pre-renders pages at build time, serving static HTML with optional hydration for interactivity.</li> </ul>"},{"location":"vue-interview-roadmap/10.3-spa-ssr-ssg/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/10.3-spa-ssr-ssg/#spa","title":"SPA","text":"<p>Traditional Vue CLI or Vite setups build an SPA. The server sends a minimal HTML shell and a JavaScript bundle. Pros: simple deployment, dynamic interactivity. Cons: blank initial screen until JS loads, less SEO-friendly unless content is rendered client-side after fetch.</p>"},{"location":"vue-interview-roadmap/10.3-spa-ssr-ssg/#ssr","title":"SSR","text":"<p>SSR generates HTML on demand using server runtime (Node, Nitro). Pros include better Time to First Byte (TTFB), SEO, and social sharing metadata. Cons: increased server complexity, higher infrastructure cost, need to handle per-request state and caching.</p>"},{"location":"vue-interview-roadmap/10.3-spa-ssr-ssg/#ssg","title":"SSG","text":"<p>SSG builds HTML at compile time (Nuxt <code>nuxi generate</code>). Pros: CDN-friendly, low runtime cost, fast initial render. Cons: limited to content known at build time; dynamic data requires client fetching or incremental regeneration.</p>"},{"location":"vue-interview-roadmap/10.3-spa-ssr-ssg/#code-example","title":"Code Example","text":"<pre><code># Nuxt 3 rendering modes\nnuxi dev        # hybrid (SSR during dev)\nnuxi build      # produces server bundle for SSR\nnuxi generate   # outputs static site (SSG)\n</code></pre>"},{"location":"vue-interview-roadmap/10.3-spa-ssr-ssg/#resources","title":"Resources","text":"<ul> <li>Nuxt 3 Docs \u2013 Rendering Modes \u2013 explains SPA, SSR, SSG, and hybrid.</li> <li>Vue.js Docs \u2013 SSR vs SSG \u2013 trade-offs overview.</li> <li>Vercel Blog \u2013 Understanding Rendering Strategies \u2013 broader context for deployment decisions.</li> </ul>"},{"location":"vue-interview-roadmap/10.4-internationalization/","title":"10.4 How do you handle internationalization in Vue (vue-i18n)?","text":""},{"location":"vue-interview-roadmap/10.4-internationalization/#quick-revision","title":"Quick Revision","text":"<ul> <li><code>vue-i18n</code> manages translations, locale switching, pluralization, and message formatting.</li> <li>Configure the i18n plugin with locale messages and use the <code>$t</code> function or <code>useI18n</code> composable in components.</li> <li>Support lazy-loaded locales, number/date formatting, and fallback locales for missing keys.</li> </ul>"},{"location":"vue-interview-roadmap/10.4-internationalization/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/10.4-internationalization/#setup","title":"Setup","text":"<p>Install <code>vue-i18n</code>, create an i18n instance with messages, and register it on the app. Define fallback locales and message structure (nested objects). Use JSON, YAML, or lazy-loaded message files for larger apps.</p>"},{"location":"vue-interview-roadmap/10.4-internationalization/#usage-in-components","title":"Usage in Components","text":"<p>In Options API, call <code>this.$t('greeting')</code>; in Composition API, use <code>const { t, locale } = useI18n()</code>. For dynamic parameters, pass objects (<code>t('invite', { name })</code>). Pluralization uses ICU syntax (<code>{count, plural, one {# item} other {# items}}</code>).</p>"},{"location":"vue-interview-roadmap/10.4-internationalization/#advanced-features","title":"Advanced Features","text":"<p>Lazy load locales via dynamic imports to reduce bundle size. Use <code>datetimeFormats</code> and <code>numberFormats</code> for localization. Manage locale persistence via cookies/localStorage. Combine with <code>vue-router</code> to localize routes.</p>"},{"location":"vue-interview-roadmap/10.4-internationalization/#code-example","title":"Code Example","text":"<p><pre><code>// i18n.js\nimport { createI18n } from 'vue-i18n';\n\nexport const i18n = createI18n({\n  locale: 'en',\n  fallbackLocale: 'en',\n  messages: {\n    en: { hello: 'Hello {name}!' },\n    fr: { hello: 'Bonjour {name} !' },\n  },\n});\n</code></pre> <pre><code>&lt;script setup&gt;\nimport { useI18n } from 'vue-i18n';\n\nconst { t, locale } = useI18n();\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;p&gt;{{ t('hello', { name: 'Chlo\u00e9' }) }}&lt;/p&gt;\n  &lt;button @click=\"locale.value = locale.value === 'en' ? 'fr' : 'en'\"&gt;Switch&lt;/button&gt;\n&lt;/template&gt;\n</code></pre></p>"},{"location":"vue-interview-roadmap/10.4-internationalization/#resources","title":"Resources","text":"<ul> <li>vue-i18n Documentation \u2013 plugin setup, ICU syntax, formatting.</li> <li>Intlify Guide \u2013 Lazy Loading \u2013 loading locales on demand.</li> <li>Nuxt i18n Module \u2013 integration for Nuxt-based apps with routing.</li> </ul>"},{"location":"vue-interview-roadmap/11.1-code-splitting/","title":"11.1 How do you manage code splitting and lazy loading in Vue?","text":""},{"location":"vue-interview-roadmap/11.1-code-splitting/#quick-revision","title":"Quick Revision","text":"<ul> <li>Use dynamic imports and async components to load code on demand, reducing initial bundle size.</li> <li>Vue Router supports lazy loading via route-level dynamic imports and prefetching strategies.</li> <li>Analyze bundles with tools (Vite <code>--mode analyze</code>, webpack-bundle-analyzer) and group chunks intelligently.</li> </ul>"},{"location":"vue-interview-roadmap/11.1-code-splitting/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/11.1-code-splitting/#dynamic-imports","title":"Dynamic Imports","text":"<p><code>import('./Component.vue')</code> returns a promise that bundlers split into separate chunks. Combined with <code>defineAsyncComponent</code>, components load only when needed. Use webpack magic comments (<code>/* webpackChunkName: \"group-admin\" */</code>) or Vite\u2019s <code>?inline</code>/<code>?raw</code> modifiers to control bundling.</p>"},{"location":"vue-interview-roadmap/11.1-code-splitting/#routing-integration","title":"Routing Integration","text":"<p>For routes, define <code>component: () =&gt; import('./views/Admin.vue')</code>. Vue Router loads the chunk when the route is visited. Pair with route-level guards or <code>Suspense</code> for loading indicators. Prefetch critical routes using <code>&lt;link rel=\"prefetch\"&gt;</code> or service workers.</p>"},{"location":"vue-interview-roadmap/11.1-code-splitting/#optimization","title":"Optimization","text":"<p>Group related components to avoid excessive chunking. Monitor bundle sizes with analyzers and configure cache-busting filenames. For shared dependencies, let bundler extract vendor chunks. Consider dynamic <code>import.meta.glob</code> in Vite for auto-generated routes.</p>"},{"location":"vue-interview-roadmap/11.1-code-splitting/#code-example","title":"Code Example","text":"<pre><code>const routes = [\n  {\n    path: '/reports',\n    component: () =&gt; import(/* webpackChunkName: \"reports\" */ './views/Reports.vue'),\n  },\n];\n</code></pre>"},{"location":"vue-interview-roadmap/11.1-code-splitting/#resources","title":"Resources","text":"<ul> <li>Vue.js Docs \u2013 Async Components \u2013 covers dynamic imports and Suspense.</li> <li>Vue Router Docs \u2013 Lazy Loading \u2013 route-level code splitting.</li> <li>Vite Guide \u2013 Dynamic Imports \u2013 bundling behavior and glob imports.</li> </ul>"},{"location":"vue-interview-roadmap/11.2-composition-api-best-practices/","title":"11.2 What are Composition API best practices for scaling large projects?","text":""},{"location":"vue-interview-roadmap/11.2-composition-api-best-practices/#quick-revision","title":"Quick Revision","text":"<ul> <li>Organize logic into composables with clear naming, documented inputs/outputs, and unit tests.</li> <li>Use TypeScript with explicit return types and interfaces to maintain contracts.</li> <li>Maintain folder conventions (e.g., <code>composables/</code>, <code>stores/</code>) and avoid global singletons unless necessary.</li> </ul>"},{"location":"vue-interview-roadmap/11.2-composition-api-best-practices/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/11.2-composition-api-best-practices/#composable-design","title":"Composable Design","text":"<p>Create focused composables that handle one concern (e.g., <code>useAuth</code>, <code>useForm</code>). Accept parameters to avoid hidden dependencies and return refs/reactive objects with descriptive property names. Document expected lifecycle usage (e.g., requires setup inside components).</p>"},{"location":"vue-interview-roadmap/11.2-composition-api-best-practices/#type-safety-reusability","title":"Type Safety &amp; Reusability","text":"<p>Adopt TypeScript or JSDoc to describe composable interfaces. Return readonly refs when exposing derived state to prevent external mutation. Use <code>provide</code>/<code>inject</code> or Pinia for shared state rather than global variables. Compose smaller composables to build complex features.</p>"},{"location":"vue-interview-roadmap/11.2-composition-api-best-practices/#project-structure-testing","title":"Project Structure &amp; Testing","text":"<p>Group composables under <code>src/composables</code> and create index files if necessary. Write unit tests with Vitest to validate edge cases. Track dependencies between composables to prevent circular imports. Use linting rules (eslint-plugin-vue) and naming conventions (<code>useX</code>) for discoverability.</p>"},{"location":"vue-interview-roadmap/11.2-composition-api-best-practices/#code-example","title":"Code Example","text":"<pre><code>// useAuth.ts\nimport { ref, computed } from 'vue';\n\nexport function useAuth(api) {\n  const user = ref(null);\n  const loading = ref(false);\n\n  async function login(credentials) {\n    loading.value = true;\n    user.value = await api.login(credentials);\n    loading.value = false;\n  }\n\n  const isAuthenticated = computed(() =&gt; !!user.value);\n\n  return { user, loading, login, isAuthenticated };\n}\n</code></pre>"},{"location":"vue-interview-roadmap/11.2-composition-api-best-practices/#resources","title":"Resources","text":"<ul> <li>Vue.js Docs \u2013 Composables \u2013 best practices and naming conventions.</li> <li>Pinia Documentation \u2013 complements Composition API for shared state.</li> <li>VueUse Source \u2013 reference for well-structured community composables.</li> </ul>"},{"location":"vue-interview-roadmap/11.3-typescript-with-vue/","title":"11.3 How do you integrate TypeScript with Vue 3?","text":""},{"location":"vue-interview-roadmap/11.3-typescript-with-vue/#quick-revision","title":"Quick Revision","text":"<ul> <li>Use the official <code>vue-tsc</code> tooling, <code>&lt;script lang=\"ts\"&gt;</code>, and Volar extension for type checking and IDE support.</li> <li>Define component props/emits with <code>defineProps</code>/<code>defineEmits</code> generics or <code>PropType</code> to leverage static typing.</li> <li>Configure build tooling (Vite, Vue CLI) to run <code>vue-tsc --noEmit</code> and integrate ESLint with TypeScript rules.</li> </ul>"},{"location":"vue-interview-roadmap/11.3-typescript-with-vue/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/11.3-typescript-with-vue/#project-setup","title":"Project Setup","text":"<p>Scaffold with <code>npm create vue@latest</code> and choose TypeScript, or add TypeScript to existing projects by installing <code>typescript</code>, <code>vue-tsc</code>, and <code>@tsconfig</code>. Configure <code>tsconfig.json</code> for strict mode and include <code>.vue</code> files via shim declarations (<code>env.d.ts</code>).</p>"},{"location":"vue-interview-roadmap/11.3-typescript-with-vue/#typing-components","title":"Typing Components","text":"<p>In <code>&lt;script setup lang=\"ts\"&gt;</code>, declare props using <code>const props = defineProps&lt;{ msg: string }&gt;()</code>. Use <code>defineEmits&lt;{ (e: 'submit', value: string): void }&gt;()</code> for event typing. For Options API, use <code>defineComponent</code> with generics. Global components and plugins can augment module declarations for typing.</p>"},{"location":"vue-interview-roadmap/11.3-typescript-with-vue/#tooling-checks","title":"Tooling &amp; Checks","text":"<p>Run <code>vue-tsc --noEmit</code> during CI for template and script type checking. Use ESLint with <code>@typescript-eslint</code> plugin. Prefer Volar over Vetur for Vue 3 TypeScript support. Handle third-party libraries with type definitions or <code>declare module</code> shims.</p>"},{"location":"vue-interview-roadmap/11.3-typescript-with-vue/#code-example","title":"Code Example","text":"<pre><code>&lt;script setup lang=\"ts\"&gt;\nconst props = defineProps&lt;{ count: number }&gt;();\nconst emit = defineEmits&lt;{ (e: 'update:count', value: number): void }&gt;();\n\nfunction increment() {\n  emit('update:count', props.count + 1);\n}\n&lt;/script&gt;\n</code></pre>"},{"location":"vue-interview-roadmap/11.3-typescript-with-vue/#resources","title":"Resources","text":"<ul> <li>Vue.js Docs \u2013 TypeScript Support \u2013 official setup and patterns.</li> <li>Volar Extension \u2013 IDE support for TypeScript in Vue.</li> <li>vue-tsc Documentation \u2013 CLI for type checking SFCs.</li> </ul>"},{"location":"vue-interview-roadmap/11.4-suspense-async-setup/","title":"11.4 How do suspense and async setup work in Vue 3?","text":""},{"location":"vue-interview-roadmap/11.4-suspense-async-setup/#quick-revision","title":"Quick Revision","text":"<ul> <li><code>Suspense</code> waits for async dependencies (async setup, async components) before rendering, showing fallback content meanwhile.</li> <li><code>setup()</code> can be <code>async</code> or return a promise; Vue suspends rendering until it resolves.</li> <li>Use Suspense for data fetching, lazy loading, and coordinating multiple async tasks with error handling.</li> </ul>"},{"location":"vue-interview-roadmap/11.4-suspense-async-setup/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/11.4-suspense-async-setup/#async-setup","title":"Async setup()","text":"<p>When <code>setup()</code> is marked <code>async</code> or returns a promise, Vue treats the component as async. It waits for the promise to resolve, providing resolved data to the template. During SSR, async setup ensures data is ready before rendering HTML.</p>"},{"location":"vue-interview-roadmap/11.4-suspense-async-setup/#suspense-component","title":"Suspense Component","text":"<p>Wrap async components in <code>&lt;Suspense&gt;</code>. The default slot renders once all async dependencies resolve; the fallback slot renders while pending. Use the <code>onResolve</code> and <code>onFallback</code> events to react to state changes. Suspense works with nested async components.</p>"},{"location":"vue-interview-roadmap/11.4-suspense-async-setup/#error-handling","title":"Error Handling","text":"<p>If async setup throws, the error propagates to error boundaries (<code>onErrorCaptured</code>). Combine Suspense with <code>&lt;template #error&gt;</code> via libraries or custom wrappers to show error UI. Avoid long-running async operations blocking UI; use timeouts or streaming for better UX.</p>"},{"location":"vue-interview-roadmap/11.4-suspense-async-setup/#code-example","title":"Code Example","text":"<p><pre><code>&lt;template&gt;\n  &lt;Suspense&gt;\n    &lt;template #default&gt;\n      &lt;AsyncProfile /&gt;\n    &lt;/template&gt;\n    &lt;template #fallback&gt;\n      &lt;p&gt;Loading profile\u2026&lt;/p&gt;\n    &lt;/template&gt;\n  &lt;/Suspense&gt;\n&lt;/template&gt;\n</code></pre> <pre><code>&lt;script setup&gt;\nimport { ref } from 'vue';\n\nconst profile = ref(null);\n\nconst data = await fetch('/api/profile').then((res) =&gt; res.json());\nprofile.value = data;\n&lt;/script&gt;\n</code></pre></p>"},{"location":"vue-interview-roadmap/11.4-suspense-async-setup/#resources","title":"Resources","text":"<ul> <li>Vue.js Docs \u2013 Suspense \u2013 usage patterns and limitations.</li> <li>Vue.js Docs \u2013 Async setup \u2013 explains async setup semantics.</li> <li>Vue SSR Guide \u2013 Suspense \u2013 SSR considerations for async components.</li> </ul>"},{"location":"vue-interview-roadmap/11.5-concurrent-rendering/","title":"11.5 Explain how Vue handles concurrent rendering and async updates.","text":""},{"location":"vue-interview-roadmap/11.5-concurrent-rendering/#quick-revision","title":"Quick Revision","text":"<ul> <li>Vue 3 uses a job queue and microtask scheduling to batch reactive updates, preventing unnecessary renders.</li> <li>Suspense and async components allow Vue to pause rendering while awaiting promises, but Vue does not implement React-style concurrent mode.</li> <li><code>nextTick</code> and scheduler APIs let you coordinate DOM updates after Vue flushes the queue.</li> </ul>"},{"location":"vue-interview-roadmap/11.5-concurrent-rendering/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/11.5-concurrent-rendering/#scheduler-job-queue","title":"Scheduler &amp; Job Queue","text":"<p>When reactive state changes, Vue queues effect jobs and flushes them asynchronously (microtasks). Multiple state changes within the same tick collapse into one render. Vue prioritizes component updates over user-created jobs, ensuring consistent UI.</p>"},{"location":"vue-interview-roadmap/11.5-concurrent-rendering/#async-components-suspense","title":"Async Components &amp; Suspense","text":"<p>Async setup and Suspense introduce controlled async rendering: Vue can delay rendering a branch until promises resolve, showing fallback content. However, Vue still renders synchronously once data is ready; it doesn\u2019t interrupt rendering mid-way like React concurrent mode.</p>"},{"location":"vue-interview-roadmap/11.5-concurrent-rendering/#nexttick-custom-scheduling","title":"nextTick &amp; Custom Scheduling","text":"<p><code>nextTick</code> allows waiting for Vue\u2019s DOM updates before running code. Advanced users can provide a custom scheduler when creating effects to integrate with requestAnimationFrame. Libraries like VueUse offer throttled/debounced refs to manage async update patterns.</p>"},{"location":"vue-interview-roadmap/11.5-concurrent-rendering/#code-example","title":"Code Example","text":"<pre><code>import { ref, nextTick } from 'vue';\n\nconst count = ref(0);\ncount.value++;\nawait nextTick();\nconsole.log(document.querySelector('#count').textContent);\n</code></pre>"},{"location":"vue-interview-roadmap/11.5-concurrent-rendering/#resources","title":"Resources","text":"<ul> <li>Vue.js Docs \u2013 Reactivity in Depth \u2013 explains the scheduler and job queue.</li> <li>Vue.js Docs \u2013 nextTick \u2013 usage patterns for post-update logic.</li> <li>Evan You \u2013 State of Vue 3 (VueConf) \u2013 discussion on Vue\u2019s async update strategy vs React concurrent mode.</li> </ul>"},{"location":"vue-interview-roadmap/11.6-tree-shaking/","title":"11.6 What is tree-shaking in Vue 3 and how does it improve performance?","text":""},{"location":"vue-interview-roadmap/11.6-tree-shaking/#quick-revision","title":"Quick Revision","text":"<ul> <li>Tree-shaking removes unused code from the bundle during build, reducing payload size.</li> <li>Vue 3\u2019s modular architecture exposes ES modules so bundlers can drop unused APIs (<code>ref</code>, <code>watch</code>, etc.).</li> <li>Combine tree-shaking with component-level code splitting and proper imports to minimize shipped code.</li> </ul>"},{"location":"vue-interview-roadmap/11.6-tree-shaking/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/11.6-tree-shaking/#modular-core","title":"Modular Core","text":"<p>Vue 3 reorganized the core into packages (<code>@vue/runtime-core</code>, <code>@vue/reactivity</code>, etc.) with named exports. When you import only what you need, bundlers (Rollup, esbuild) can statically analyze imports and eliminate unused exports.</p>"},{"location":"vue-interview-roadmap/11.6-tree-shaking/#best-practices","title":"Best Practices","text":"<p>Avoid importing the entire Vue object (<code>import Vue from 'vue'</code>). Instead, use named imports (<code>import { ref } from 'vue'</code>). Ensure bundler config is in production mode with minification and dead-code elimination enabled. For libraries, offer ESM builds with side-effect-free modules to enable tree-shaking.</p>"},{"location":"vue-interview-roadmap/11.6-tree-shaking/#impact","title":"Impact","text":"<p>Smaller bundles mean faster load times and better performance. Tree-shaking also enables partial builds (e.g., using only the reactivity package without the DOM runtime). Combined with <code>vite</code> or Rollup, Vue apps benefit from significant size reductions compared to Vue 2 builds.</p>"},{"location":"vue-interview-roadmap/11.6-tree-shaking/#code-example","title":"Code Example","text":"<pre><code>// Good: tree-shakable\nimport { createApp, ref } from 'vue';\n\n// Bad: prevents tree-shaking in some bundlers\n// import * as Vue from 'vue';\n</code></pre>"},{"location":"vue-interview-roadmap/11.6-tree-shaking/#resources","title":"Resources","text":"<ul> <li>Vue.js Docs \u2013 Tree-shaking Support \u2013 notes on ESM builds and bundlers.</li> <li>Vite Documentation \u2013 Dependency Pre-Bundling \u2013 how Vite handles tree-shaking.</li> <li>Rollup Tree-Shaking Guide \u2013 underlying concepts used by Vue tooling.</li> </ul>"},{"location":"vue-interview-roadmap/2.1-core-directives/","title":"2.1 Can you explain the role of directives like v-bind, v-model, and v-for?","text":""},{"location":"vue-interview-roadmap/2.1-core-directives/#quick-revision","title":"Quick Revision","text":"<ul> <li><code>v-bind</code> dynamically binds attributes/props to reactive expressions, often shortened as <code>:</code>.</li> <li><code>v-model</code> creates two-way bindings by combining <code>:value</code> and <code>@update</code> semantics for inputs and custom components.</li> <li><code>v-for</code> renders lists by iterating over arrays/objects; always provide a unique <code>key</code> for efficient updates.</li> </ul>"},{"location":"vue-interview-roadmap/2.1-core-directives/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/2.1-core-directives/#v-bind","title":"v-bind","text":"<p><code>v-bind</code> keeps HTML attributes or component props in sync with reactive state. You can bind to classes (<code>:class</code>), styles (<code>:style</code>), and even pass entire attribute objects with <code>v-bind=\"object\"</code>. On components, Vue validates props and triggers updates when bound values change.</p>"},{"location":"vue-interview-roadmap/2.1-core-directives/#v-model","title":"v-model","text":"<p><code>v-model</code> is syntactic sugar that pairs <code>:modelValue</code> (or <code>value</code> on native inputs) with an <code>@update:modelValue</code> event. For native inputs it listens to <code>input</code> events; custom components must emit the <code>update:modelValue</code> event (or customize via <code>modelModifiers</code>/arguments). Modifiers like <code>.trim</code>, <code>.number</code>, and <code>.lazy</code> adjust update behavior.</p>"},{"location":"vue-interview-roadmap/2.1-core-directives/#v-for","title":"v-for","text":"<p><code>v-for=\"item in items\"</code> duplicates template blocks for each list entry. Vue reuses DOM nodes by tracking each item\u2019s <code>key</code>. Without stable keys, Vue falls back to index-based reuse, which can lead to rendering bugs. For objects, the syntax <code>v-for=\"(value, key, index) in object\"</code> exposes additional context. Combine with <code>v-if</code> cautiously to avoid performance issues.</p>"},{"location":"vue-interview-roadmap/2.1-core-directives/#code-example","title":"Code Example","text":"<pre><code>&lt;template&gt;\n  &lt;input v-model.trim=\"form.email\" placeholder=\"Email\" /&gt;\n  &lt;ul&gt;\n    &lt;li v-for=\"user in users\" :key=\"user.id\"&gt;\n      &lt;span :class=\"{ online: user.online }\"&gt;{{ user.name }}&lt;/span&gt;\n    &lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { reactive } from 'vue';\n\nconst form = reactive({ email: '' });\nconst users = reactive([\n  { id: 1, name: 'Lea', online: true },\n  { id: 2, name: 'Kai', online: false },\n]);\n&lt;/script&gt;\n</code></pre>"},{"location":"vue-interview-roadmap/2.1-core-directives/#resources","title":"Resources","text":"<ul> <li>Vue.js Docs \u2013 Class and Style Bindings \u2013 advanced <code>v-bind</code> usage.</li> <li>Vue.js Docs \u2013 Form Input Bindings \u2013 details on <code>v-model</code>, modifiers, and custom components.</li> <li>Vue.js Docs \u2013 List Rendering \u2013 best practices for <code>v-for</code>, keys, and performance.</li> </ul>"},{"location":"vue-interview-roadmap/2.2-single-file-components/","title":"2.2 What are Single File Components (SFCs) and why are they useful?","text":""},{"location":"vue-interview-roadmap/2.2-single-file-components/#quick-revision","title":"Quick Revision","text":"<ul> <li>SFCs (<code>.vue</code> files) encapsulate template, script, and style in a single file with scoped tooling support.</li> <li>They enable build-time compilation, hot module replacement, scoped CSS, and TypeScript integration.</li> <li><code>&lt;script setup&gt;</code> and <code>&lt;style scoped&gt;</code> features streamline Composition API usage and style encapsulation.</li> </ul>"},{"location":"vue-interview-roadmap/2.2-single-file-components/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/2.2-single-file-components/#structure-tooling","title":"Structure &amp; Tooling","text":"<p>An SFC contains <code>&lt;template&gt;</code>, <code>&lt;script&gt;</code> (or <code>&lt;script setup&gt;</code>), and <code>&lt;style&gt;</code> blocks processed by the Vue compiler. During build, the template is compiled into render functions, enabling static analysis (e.g., template type-checking with Volar). Tooling like Vite or Vue CLI understands SFC syntax for hot updates and tree-shaking.</p>"},{"location":"vue-interview-roadmap/2.2-single-file-components/#encapsulation-reuse","title":"Encapsulation &amp; Reuse","text":"<p>SFCs co-locate markup, logic, and styles, improving maintainability. <code>&lt;style scoped&gt;</code> transforms CSS selectors with attribute hashes to avoid leakage. You can define multiple style blocks (e.g., module, scoped, or preprocessor languages like SCSS). Custom blocks (e.g., <code>&lt;docs&gt;</code>, <code>&lt;i18n&gt;</code>) can be processed by loaders.</p>"},{"location":"vue-interview-roadmap/2.2-single-file-components/#advanced-features","title":"Advanced Features","text":"<p><code>&lt;script setup&gt;</code> compiles to a component definition, removing boilerplate for imports and returning values. <code>&lt;script lang=\"ts\"&gt;</code> enables TypeScript. <code>&lt;template&gt;</code> can use compile-time macros (e.g., defineProps). SFCs integrate with testing tools (Vue Test Utils) and design systems by packaging reusable components.</p>"},{"location":"vue-interview-roadmap/2.2-single-file-components/#code-example","title":"Code Example","text":"<pre><code>&lt;template&gt;\n  &lt;button class=\"primary\" @click=\"emit('click')\"&gt;\n    &lt;slot&gt;Submit&lt;/slot&gt;\n  &lt;/button&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nconst emit = defineEmits(['click']);\n&lt;/script&gt;\n\n&lt;style scoped&gt;\n.primary {\n  background: #42b883;\n  border: none;\n  color: white;\n  padding: 0.5rem 1rem;\n  border-radius: 6px;\n  cursor: pointer;\n}\n&lt;/style&gt;\n</code></pre>"},{"location":"vue-interview-roadmap/2.2-single-file-components/#resources","title":"Resources","text":"<ul> <li>Vue.js Docs \u2013 Single File Components \u2013 official overview and compilation pipeline.</li> <li>Vue.js Docs \u2013 <code>&lt;script setup&gt;</code> \u2013 syntax sugar for Composition API in SFCs.</li> <li>Vue.js Docs \u2013 Scoped Styles \u2013 explains style scoping and CSS modules in SFCs.</li> </ul>"},{"location":"vue-interview-roadmap/3.1-computed-vs-watch/","title":"3.1 How do computed properties differ from watchers?","text":""},{"location":"vue-interview-roadmap/3.1-computed-vs-watch/#quick-revision","title":"Quick Revision","text":"<ul> <li>Computed properties derive reactive values with caching; they re-evaluate only when dependencies change.</li> <li>Watchers run side effects in response to reactive changes, ideal for async work or imperative tasks.</li> <li>Prefer computed properties for declarative data transformations; use watchers for effects requiring callbacks.</li> </ul>"},{"location":"vue-interview-roadmap/3.1-computed-vs-watch/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/3.1-computed-vs-watch/#computed-properties","title":"Computed Properties","text":"<p>A computed property wraps a getter function in a lazy effect. Vue tracks dependencies during evaluation and caches the result until dependencies change. Computed props can be read like data in templates and are ideal for derived state, complex calculations, and chaining with other computed values. Writable computed props define both <code>get</code> and <code>set</code>.</p>"},{"location":"vue-interview-roadmap/3.1-computed-vs-watch/#watchers","title":"Watchers","text":"<p><code>watch(source, callback)</code> observes one or more reactive sources (refs, getters, arrays) and executes a callback when they change. Watchers expose the new and previous value, support <code>immediate</code> execution, and can be flushed <code>post</code>, <code>pre</code>, or <code>sync</code>. <code>watchEffect</code> runs a reactive effect immediately and re-runs whenever dependencies change, making it great for concise side effects.</p>"},{"location":"vue-interview-roadmap/3.1-computed-vs-watch/#choosing-the-right-tool","title":"Choosing the Right Tool","text":"<p>Computed props should remain pure and free of side effects, ensuring templates stay declarative. Watchers are necessary when you need to respond to changes with asynchronous logic, manual DOM interaction, or integration with external APIs. Avoid watchers for trivial transformations that could be computed props.</p>"},{"location":"vue-interview-roadmap/3.1-computed-vs-watch/#code-example","title":"Code Example","text":"<pre><code>&lt;script setup&gt;\nimport { ref, computed, watch } from 'vue';\n\nconst first = ref('Ada');\nconst last = ref('Lovelace');\nconst fullName = computed(() =&gt; `${first.value} ${last.value}`);\n\nwatch(fullName, (newName, oldName) =&gt; {\n  console.log(`Name changed from ${oldName} to ${newName}`);\n});\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;p&gt;{{ fullName }}&lt;/p&gt;\n&lt;/template&gt;\n</code></pre>"},{"location":"vue-interview-roadmap/3.1-computed-vs-watch/#resources","title":"Resources","text":"<ul> <li>Vue.js Docs \u2013 Computed Properties \u2013 explains caching behavior and writable computed props.</li> <li>Vue.js Docs \u2013 Watchers \u2013 details <code>watch</code>, <code>watchEffect</code>, and configuration options.</li> <li>Vue.js Docs \u2013 Reactivity in Depth \u2013 covers how computed and watch share effect scheduling.</li> </ul>"},{"location":"vue-interview-roadmap/3.2-form-handling/","title":"3.2 How do you handle forms in Vue?","text":""},{"location":"vue-interview-roadmap/3.2-form-handling/#quick-revision","title":"Quick Revision","text":"<ul> <li>Use <code>v-model</code> for two-way binding on inputs, modifiers for formatting, and custom components for reusable form fields.</li> <li>Manage validation with computed rules, watchers, or libraries like Vuelidate, vee-validate, or custom composables.</li> <li>Handle submissions by preventing default events, performing async operations, and providing UX feedback (loading, errors).</li> </ul>"},{"location":"vue-interview-roadmap/3.2-form-handling/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/3.2-form-handling/#basic-binding","title":"Basic Binding","text":"<p>Vue\u2019s <code>v-model</code> syncs input value with reactive state. For checkboxes/radios, use bound arrays or values. Modifiers such as <code>.lazy</code> update on <code>change</code> events, <code>.trim</code> removes whitespace, and <code>.number</code> casts to numbers.</p>"},{"location":"vue-interview-roadmap/3.2-form-handling/#validation-strategies","title":"Validation Strategies","text":"<p>Lightweight validation can use computed properties that return error messages and watchers to trigger asynchronous checks. More complex forms benefit from composables that centralize validation logic (<code>useForm</code>, <code>useField</code>). Popular libraries provide schema-based validation, error collections, and integration with async validators.</p>"},{"location":"vue-interview-roadmap/3.2-form-handling/#submission-flow","title":"Submission Flow","text":"<p>Handle <code>@submit.prevent</code> to stop default browser behavior. Use <code>async</code> functions to send requests, set loading states, and reset forms on success. Provide accessible feedback by disabling buttons during submission and announcing errors.</p>"},{"location":"vue-interview-roadmap/3.2-form-handling/#code-example","title":"Code Example","text":"<pre><code>&lt;template&gt;\n  &lt;form @submit.prevent=\"submit\"&gt;\n    &lt;label&gt;\n      Email\n      &lt;input v-model.trim=\"form.email\" type=\"email\" /&gt;\n    &lt;/label&gt;\n    &lt;span v-if=\"errors.email\"&gt;{{ errors.email }}&lt;/span&gt;\n\n    &lt;label&gt;\n      Password\n      &lt;input v-model=\"form.password\" type=\"password\" /&gt;\n    &lt;/label&gt;\n    &lt;span v-if=\"errors.password\"&gt;{{ errors.password }}&lt;/span&gt;\n\n    &lt;button type=\"submit\" :disabled=\"loading\"&gt;{{ loading ? 'Signing in\u2026' : 'Sign in' }}&lt;/button&gt;\n  &lt;/form&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { reactive, computed, ref } from 'vue';\n\nconst form = reactive({ email: '', password: '' });\nconst loading = ref(false);\nconst errors = reactive({ email: '', password: '' });\n\nconst isValid = computed(() =&gt; {\n  errors.email = form.email.includes('@') ? '' : 'Email must contain @';\n  errors.password = form.password.length &gt;= 8 ? '' : 'Password too short';\n  return !errors.email &amp;&amp; !errors.password;\n});\n\nasync function submit() {\n  if (!isValid.value) return;\n  loading.value = true;\n  try {\n    await fakeAuth(form);\n  } catch (err) {\n    errors.password = 'Authentication failed';\n  } finally {\n    loading.value = false;\n  }\n}\n\nfunction fakeAuth({ email }) {\n  return new Promise((resolve) =&gt; setTimeout(resolve, 600));\n}\n&lt;/script&gt;\n</code></pre>"},{"location":"vue-interview-roadmap/3.2-form-handling/#resources","title":"Resources","text":"<ul> <li>Vue.js Docs \u2013 Form Input Bindings \u2013 explains <code>v-model</code> for each input type.</li> <li>vee-validate Documentation \u2013 schema-based validation for Vue 3.</li> <li>VueUse \u2013 useForm/useField Composables \u2013 utility composables for managing forms and validation.</li> </ul>"},{"location":"vue-interview-roadmap/4.1-vuex-basics/","title":"4.1 What are the basics of Vuex and how does it differ from local component state?","text":""},{"location":"vue-interview-roadmap/4.1-vuex-basics/#quick-revision","title":"Quick Revision","text":"<ul> <li>Vuex provides a centralized store with state, getters, mutations, and actions for predictable state management across components.</li> <li>Local component state is encapsulated within a component; Vuex enables global sharing, time-travel debugging, and devtools integration.</li> <li>Vuex enforces unidirectional data flow: components dispatch actions \u2192 actions commit mutations \u2192 mutations synchronously update state.</li> </ul>"},{"location":"vue-interview-roadmap/4.1-vuex-basics/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/4.1-vuex-basics/#core-concepts","title":"Core Concepts","text":"<p>Vuex organizes global state in a single store. <code>state</code> is the reactive data source, <code>getters</code> derive computed values, <code>mutations</code> are synchronous operations that change state, and <code>actions</code> handle asynchronous logic before committing mutations. Modules allow namespacing.</p>"},{"location":"vue-interview-roadmap/4.1-vuex-basics/#differences-from-local-state","title":"Differences from Local State","text":"<p>Local component state suits UI-specific data that doesn\u2019t need to be shared. When multiple components need consistent state (e.g., authentication, cart), Vuex centralizes logic, reduces prop drilling, and makes mutations traceable. Vue Devtools records mutation history for debugging and supports time travel.</p>"},{"location":"vue-interview-roadmap/4.1-vuex-basics/#workflow-best-practices","title":"Workflow &amp; Best Practices","text":"<p>Components access state via <code>useStore()</code> or helpers like <code>mapState</code>. They dispatch actions instead of committing mutations directly to keep asynchronous effects centralized. Mutations must be synchronous to keep devtools logs deterministic. Use modules to segment domains and enable lazy-loaded modules for code splitting.</p>"},{"location":"vue-interview-roadmap/4.1-vuex-basics/#code-example","title":"Code Example","text":"<pre><code>// store/index.js\nimport { createStore } from 'vuex';\n\nexport default createStore({\n  state: () =&gt; ({ count: 0 }),\n  getters: {\n    double: (state) =&gt; state.count * 2,\n  },\n  mutations: {\n    increment(state) {\n      state.count++;\n    },\n  },\n  actions: {\n    asyncIncrement({ commit }) {\n      setTimeout(() =&gt; commit('increment'), 300);\n    },\n  },\n});\n</code></pre>"},{"location":"vue-interview-roadmap/4.1-vuex-basics/#resources","title":"Resources","text":"<ul> <li>Vuex 4 Official Documentation \u2013 covers state, getters, mutations, actions, and modules.</li> <li>Vue.js Docs \u2013 State Management \u2013 explains when to choose Vuex vs local state or Pinia.</li> <li>Vue Devtools Guide \u2013 demonstrates time-travel debugging and mutation inspection.</li> </ul>"},{"location":"vue-interview-roadmap/4.2-mixins-vs-composition/","title":"4.2 How do mixins differ from the Composition API?","text":""},{"location":"vue-interview-roadmap/4.2-mixins-vs-composition/#quick-revision","title":"Quick Revision","text":"<ul> <li>Mixins merge properties into components, risking namespace collisions and unclear data flow.</li> <li>Composition API uses functions (composables) that return reactive values, offering explicit imports and reusable logic without merging.</li> <li>Composition API improves TypeScript support, tree-shaking, and traceability compared with mixins.</li> </ul>"},{"location":"vue-interview-roadmap/4.2-mixins-vs-composition/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/4.2-mixins-vs-composition/#mixins","title":"Mixins","text":"<p>Mixins are reusable option objects whose properties merge into the component. Conflicts are resolved with merge strategies (methods override, data merged). While convenient, mixins hide dependencies, make tracing origins harder, and can cause naming collisions. Multiple mixins can lead to tight coupling and implicit behavior.</p>"},{"location":"vue-interview-roadmap/4.2-mixins-vs-composition/#composition-api","title":"Composition API","text":"<p>Composables are plain functions called inside <code>setup()</code> that return reactive state and functions. Dependencies are explicit via imports, and returned values are destructured intentionally, eliminating collisions. You can parameterize composables, share reactive instances, and manage lifecycle hooks inside them.</p>"},{"location":"vue-interview-roadmap/4.2-mixins-vs-composition/#migration-considerations","title":"Migration Considerations","text":"<p>In Vue 3, mixins are still supported but discouraged for large-scale reuse. Converting to composables enhances tree-shaking and TypeScript type inference, since the returned values are typed. Devtools also show composable traces, making debugging easier.</p>"},{"location":"vue-interview-roadmap/4.2-mixins-vs-composition/#code-example","title":"Code Example","text":"<p><pre><code>// useMouse.js composable\nimport { ref, onMounted, onBeforeUnmount } from 'vue';\n\nexport function useMouse() {\n  const x = ref(0);\n  const y = ref(0);\n\n  function update(event) {\n    x.value = event.pageX;\n    y.value = event.pageY;\n  }\n\n  onMounted(() =&gt; window.addEventListener('mousemove', update));\n  onBeforeUnmount(() =&gt; window.removeEventListener('mousemove', update));\n\n  return { x, y };\n}\n</code></pre> Compared with a mixin, <code>useMouse</code> exposes its API explicitly and avoids merging lifecycle hooks implicitly.</p>"},{"location":"vue-interview-roadmap/4.2-mixins-vs-composition/#resources","title":"Resources","text":"<ul> <li>Vue.js Docs \u2013 Mixins \u2013 explains limitations and migration advice.</li> <li>Vue.js Docs \u2013 Composables \u2013 demonstrates Composition API reuse patterns.</li> <li>Vue RFC \u2013 Function-based API \u2013 motivation for replacing mixins with composables.</li> </ul>"},{"location":"vue-interview-roadmap/4.3-vuex-vs-redux/","title":"4.3 Compare Vuex with Redux. What are their strengths and weaknesses?","text":""},{"location":"vue-interview-roadmap/4.3-vuex-vs-redux/#quick-revision","title":"Quick Revision","text":"<ul> <li>Vuex is tightly integrated with Vue reactivity and mutations; Redux is framework-agnostic and uses pure reducers.</li> <li>Vuex mutations are synchronous, tracked by devtools, and leverage Vue\u2019s reactivity for updates; Redux reducers return new immutable state objects.</li> <li>Vuex is simpler for Vue projects with modules/getters; Redux offers middleware ecosystem and explicit immutability but requires more boilerplate.</li> </ul>"},{"location":"vue-interview-roadmap/4.3-vuex-vs-redux/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/4.3-vuex-vs-redux/#architecture","title":"Architecture","text":"<p>Vuex organizes state with mutations and actions. Mutations directly mutate state, and Vue\u2019s reactivity detects changes. Actions handle async logic. Redux enforces pure reducers that accept <code>(state, action)</code> and return new state objects; immutability is required for change detection. Dispatching is asynchronous but reducers are synchronous.</p>"},{"location":"vue-interview-roadmap/4.3-vuex-vs-redux/#tooling-ecosystem","title":"Tooling &amp; Ecosystem","text":"<p>Vuex integrates with Vue Devtools, supporting time-travel debugging and module inspection. It leverages Vue\u2019s plugin system and is configured once. Redux has a large middleware ecosystem (e.g., Redux Thunk, Redux Saga) and developer tools that integrate across frameworks. However, Redux typically requires more boilerplate for actions, reducers, and selectors.</p>"},{"location":"vue-interview-roadmap/4.3-vuex-vs-redux/#when-to-choose","title":"When to Choose","text":"<p>For Vue-centric applications, Vuex offers first-class support, minimal boilerplate, and direct compatibility with Composition API (<code>useStore</code>). Redux is valuable when sharing state logic across multiple frameworks or when you need advanced middleware patterns. Pinia (Vue\u2019s next-gen store) combines strengths of both by embracing Composition API and TypeScript.</p>"},{"location":"vue-interview-roadmap/4.3-vuex-vs-redux/#code-example","title":"Code Example","text":"<p><pre><code>// Redux-style reducer\nfunction counter(state = { count: 0 }, action) {\n  switch (action.type) {\n    case 'increment':\n      return { count: state.count + 1 };\n    default:\n      return state;\n  }\n}\n</code></pre> Contrast with Vuex mutations that mutate state directly, relying on Vue\u2019s reactive tracking instead of returning new objects.</p>"},{"location":"vue-interview-roadmap/4.3-vuex-vs-redux/#resources","title":"Resources","text":"<ul> <li>Vuex vs Redux Comparison \u2013 Vue Docs \u2013 official note on differences.</li> <li>Redux Documentation \u2013 explains core principles and immutability.</li> <li>Pinia Docs \u2013 Why Not Vuex \u2013 context for newer state solutions influenced by Redux patterns.</li> </ul>"},{"location":"vue-interview-roadmap/4.4-reactivity-caveats/","title":"4.4 What are some reactivity caveats in Vue (like array/object changes in Vue 2)?","text":""},{"location":"vue-interview-roadmap/4.4-reactivity-caveats/#quick-revision","title":"Quick Revision","text":"<ul> <li>Vue 2 cannot detect property addition/deletion or index-based array mutations without helpers; Vue 3 resolves this with Proxies.</li> <li>Use <code>Vue.set</code>/<code>this.$set</code> and <code>Vue.delete</code> in Vue 2 to ensure new properties are reactive, or array methods like <code>splice</code>.</li> <li>In Vue 3, prefer <code>reactive</code>/<code>ref</code> and avoid mutating raw objects returned from <code>toRaw</code>; use <code>markRaw</code> for opt-outs.</li> </ul>"},{"location":"vue-interview-roadmap/4.4-reactivity-caveats/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/4.4-reactivity-caveats/#vue-2-limitations","title":"Vue 2 Limitations","text":"<p>Because Vue 2 proxies each property using <code>Object.defineProperty</code>, it can\u2019t intercept property additions. Adding <code>obj.newProp = 1</code> won\u2019t trigger updates. Similarly, setting <code>arr[index] = value</code> won\u2019t be reactive. Use <code>Vue.set(obj, 'newProp', value)</code> or <code>this.$set</code> to define reactive getters/setters. For arrays, prefer methods like <code>splice</code>, <code>push</code>, or <code>shift</code>, which Vue intercepts.</p>"},{"location":"vue-interview-roadmap/4.4-reactivity-caveats/#vue-3-improvements","title":"Vue 3 Improvements","text":"<p>Vue 3\u2019s Proxy-based system tracks operations like <code>set</code>, <code>deleteProperty</code>, and <code>has</code>. Property additions and deletions are reactive. However, some caveats remain: using <code>toRaw</code> to bypass reactivity requires manual updates, and storing non-reactive libraries might need <code>markRaw</code> to prevent deep proxying. When destructuring reactive objects, you may lose reactivity unless you convert to refs (<code>toRefs</code>).</p>"},{"location":"vue-interview-roadmap/4.4-reactivity-caveats/#best-practices","title":"Best Practices","text":"<p>Avoid mutating reactive objects outside Vue\u2019s reactivity (e.g., by reassigning <code>state = newObj</code> inside <code>setup</code>). For arrays, rely on <code>push</code>, <code>splice</code>, or <code>arr[index] = value</code> (works in Vue 3). In Vue 2 legacy projects, document usage of <code>Vue.set</code> and avoid replacing entire reactive objects without using <code>Object.assign</code> to keep references.</p>"},{"location":"vue-interview-roadmap/4.4-reactivity-caveats/#code-example","title":"Code Example","text":"<pre><code>// Vue 2 example\ndata() {\n  return { user: { name: 'Evan' }, tags: ['vue'] };\n},\nmounted() {\n  this.$set(this.user, 'role', 'maintainer'); // reactive addition\n  this.tags.splice(1, 0, 'frontend');\n}\n</code></pre>"},{"location":"vue-interview-roadmap/4.4-reactivity-caveats/#resources","title":"Resources","text":"<ul> <li>Vue 2 Docs \u2013 Reactivity Caveats \u2013 legacy guidance on arrays/objects.</li> <li>Vue 3 Docs \u2013 Reactivity in Depth \u2013 explains Proxy traps and caveats.</li> <li>Vue.js Docs \u2013 toRef and toRefs \u2013 avoiding reactivity loss when destructuring.</li> </ul>"},{"location":"vue-interview-roadmap/5.1-navigation-guards/","title":"5.1 How do Vue Router navigation guards work?","text":""},{"location":"vue-interview-roadmap/5.1-navigation-guards/#quick-revision","title":"Quick Revision","text":"<ul> <li>Navigation guards are hooks that execute during route changes, allowing auth checks, redirects, or data fetching.</li> <li>Guards exist globally (<code>beforeEach</code>, <code>beforeResolve</code>, <code>afterEach</code>), per-route (<code>beforeEnter</code>), and in-component (<code>beforeRouteEnter</code>, etc.).</li> <li>Guards must call <code>next()</code> (Vue Router 3) or return values/promises (Vue Router 4) to control navigation flow.</li> </ul>"},{"location":"vue-interview-roadmap/5.1-navigation-guards/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/5.1-navigation-guards/#guard-lifecycle","title":"Guard Lifecycle","text":"<p>When navigating, Vue Router evaluates guards in order: leaving guards (<code>beforeRouteLeave</code>), global <code>beforeEach</code>, per-route <code>beforeEnter</code>, in-component <code>beforeRouteEnter</code>, and finally <code>beforeResolve</code>. After the navigation is confirmed, <code>afterEach</code> runs. Guards can cancel, redirect, or allow navigation.</p>"},{"location":"vue-interview-roadmap/5.1-navigation-guards/#vue-router-4-syntax","title":"Vue Router 4 Syntax","text":"<p>In Vue Router 4 (Vue 3), guards can return <code>false</code> (cancel), a route location (redirect), or a promise. Asynchronous guards can <code>await</code> operations. You no longer call <code>next()</code>; returning suffices (though <code>next</code> still works for compatibility). Guards receive <code>to</code>, <code>from</code>, and a <code>next</code> callback.</p>"},{"location":"vue-interview-roadmap/5.1-navigation-guards/#use-cases","title":"Use Cases","text":"<p>Common uses include authentication (redirect to login if not authorized), fetching data before entering a route, analytics tracking, or confirming unsaved changes. Combine guards with meta fields (e.g., <code>meta.requiresAuth</code>) to centralize logic.</p>"},{"location":"vue-interview-roadmap/5.1-navigation-guards/#code-example","title":"Code Example","text":"<pre><code>// router.js\nrouter.beforeEach(async (to, from) =&gt; {\n  if (to.meta.requiresAuth &amp;&amp; !(await isAuthenticated())) {\n    return { name: 'login', query: { redirect: to.fullPath } };\n  }\n  // returning nothing continues navigation\n});\n</code></pre>"},{"location":"vue-interview-roadmap/5.1-navigation-guards/#resources","title":"Resources","text":"<ul> <li>Vue Router Docs \u2013 Navigation Guards \u2013 full lifecycle explanation.</li> <li>Vue Router Docs \u2013 Meta Fields \u2013 using meta info with guards.</li> <li>Vue Router Docs \u2013 Composition API \u2013 using guards with composition utilities like <code>onBeforeRouteUpdate</code>.</li> </ul>"},{"location":"vue-interview-roadmap/5.2-guard-types/","title":"5.2 What\u2019s the difference between beforeEach, beforeEnter, and beforeRouteLeave guards?","text":""},{"location":"vue-interview-roadmap/5.2-guard-types/#quick-revision","title":"Quick Revision","text":"<ul> <li><code>beforeEach</code> is a global guard that runs on every navigation, ideal for app-wide checks like authentication.</li> <li><code>beforeEnter</code> is defined per-route and runs only when entering that specific route (not on component updates).</li> <li><code>beforeRouteLeave</code> is an in-component guard that runs when leaving the current route, often used for unsaved-change prompts.</li> </ul>"},{"location":"vue-interview-roadmap/5.2-guard-types/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/5.2-guard-types/#global-guard-beforeeach","title":"Global Guard: beforeEach","text":"<p>Registered on the router instance, <code>beforeEach</code> receives <code>to</code>/<code>from</code> and runs before every navigation, including redirects. Use it for logic that applies universally, such as verifying auth meta fields or logging page views. In Vue Router 4, return <code>false</code> to cancel or a route object to redirect.</p>"},{"location":"vue-interview-roadmap/5.2-guard-types/#route-specific-guard-beforeenter","title":"Route-Specific Guard: beforeEnter","text":"<p>Configured directly in a route record, <code>beforeEnter</code> executes when navigating into that route for the first time or via redirects, but not on query/param updates when the component is reused. This guard is great for fetching route-specific data or validating route params before component creation.</p>"},{"location":"vue-interview-roadmap/5.2-guard-types/#in-component-guard-beforerouteleave","title":"In-Component Guard: beforeRouteLeave","text":"<p>Defined within component options or via Composition API (<code>onBeforeRouteLeave</code>), this guard runs when navigation is leaving the component\u2019s route. It can prevent navigation if there are unsaved changes. Because it has access to component instance state, it can read forms or unsaved drafts.</p>"},{"location":"vue-interview-roadmap/5.2-guard-types/#code-example","title":"Code Example","text":"<p><pre><code>// router.js\nconst routes = [\n  {\n    path: '/admin',\n    component: () =&gt; import('./AdminDashboard.vue'),\n    beforeEnter: (to, from) =&gt; {\n      if (!hasRole('admin')) return { name: 'forbidden' };\n    },\n  },\n];\n\nrouter.beforeEach((to) =&gt; {\n  if (to.meta.requiresAuth &amp;&amp; !isLoggedIn()) return { name: 'login' };\n});\n</code></pre> <pre><code>// In a component\nimport { onBeforeRouteLeave } from 'vue-router';\n\nonBeforeRouteLeave((to, from, next) =&gt; {\n  if (formHasUnsavedChanges()) {\n    const leave = window.confirm('Discard changes?');\n    if (!leave) return false;\n  }\n});\n</code></pre></p>"},{"location":"vue-interview-roadmap/5.2-guard-types/#resources","title":"Resources","text":"<ul> <li>Vue Router Docs \u2013 Global Guards \u2013 usage of <code>beforeEach</code>.</li> <li>Vue Router Docs \u2013 Per-Route Guards \u2013 explains <code>beforeEnter</code> behavior.</li> <li>Vue Router Docs \u2013 In-Component Guards \u2013 details <code>beforeRouteLeave</code> and Composition API equivalents.</li> </ul>"},{"location":"vue-interview-roadmap/6.1-async-components/","title":"6.1 How do you create and use async components in Vue?","text":""},{"location":"vue-interview-roadmap/6.1-async-components/#quick-revision","title":"Quick Revision","text":"<ul> <li>Async components defer loading of component code until needed, reducing initial bundle size.</li> <li>Use <code>defineAsyncComponent</code> (Vue 3) or dynamic imports with <code>defineAsyncComponent(() =&gt; import('./Foo.vue'))</code>.</li> <li>Provide loading/error components and timeouts for better UX when lazy loading.</li> </ul>"},{"location":"vue-interview-roadmap/6.1-async-components/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/6.1-async-components/#defining-async-components","title":"Defining Async Components","text":"<p>In Vue 3, import <code>defineAsyncComponent</code> and pass a loader function that returns a promise. The component resolves when the promise fulfills. In templates, async components behave like normal components; Vue handles the promise internally.</p>"},{"location":"vue-interview-roadmap/6.1-async-components/#advanced-options","title":"Advanced Options","text":"<p><code>defineAsyncComponent</code> accepts an options object allowing <code>loader</code>, <code>loadingComponent</code>, <code>errorComponent</code>, <code>delay</code>, and <code>timeout</code>. This lets you show skeletons or fallbacks while fetching the component. Combine with dynamic routing or conditional rendering to load on demand.</p>"},{"location":"vue-interview-roadmap/6.1-async-components/#usage-patterns","title":"Usage Patterns","text":"<p>Async components pair well with code-splitting via bundlers (Vite/Webpack). They work with Suspense in Vue 3, enabling placeholder templates until async components resolve. For route-level code splitting, use dynamic imports in Vue Router\u2019s route records.</p>"},{"location":"vue-interview-roadmap/6.1-async-components/#code-example","title":"Code Example","text":"<p><pre><code>import { defineAsyncComponent } from 'vue';\n\nexport const AsyncChart = defineAsyncComponent({\n  loader: () =&gt; import('./Chart.vue'),\n  loadingComponent: () =&gt; import('./ChartSkeleton.vue'),\n  delay: 200,\n  timeout: 5000,\n});\n</code></pre> <pre><code>&lt;template&gt;\n  &lt;Suspense&gt;\n    &lt;template #default&gt;\n      &lt;AsyncChart /&gt;\n    &lt;/template&gt;\n    &lt;template #fallback&gt;\n      &lt;p&gt;Loading chart\u2026&lt;/p&gt;\n    &lt;/template&gt;\n  &lt;/Suspense&gt;\n&lt;/template&gt;\n</code></pre></p>"},{"location":"vue-interview-roadmap/6.1-async-components/#resources","title":"Resources","text":"<ul> <li>Vue.js Docs \u2013 Async Components \u2013 official usage patterns and options.</li> <li>Vue.js Docs \u2013 Suspense \u2013 integrating async components with fallback UI.</li> <li>Vite Docs \u2013 Code Splitting \u2013 explains how dynamic imports produce separate chunks.</li> </ul>"},{"location":"vue-interview-roadmap/6.2-vue-cli-basics/","title":"6.2 What are the basics of the Vue CLI?","text":""},{"location":"vue-interview-roadmap/6.2-vue-cli-basics/#quick-revision","title":"Quick Revision","text":"<ul> <li>Vue CLI (now in maintenance) scaffolds Vue 2/3 projects with webpack-based build tooling and plugin system.</li> <li>It offers interactive project creation, zero-config defaults, and extensibility through CLI plugins (TypeScript, Vuex, Router).</li> <li>Modern projects often use Vite or <code>create-vue</code>, but Vue CLI remains relevant for legacy webpack workflows.</li> </ul>"},{"location":"vue-interview-roadmap/6.2-vue-cli-basics/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/6.2-vue-cli-basics/#project-creation","title":"Project Creation","text":"<p>Running <code>vue create my-app</code> launches an interactive prompt to select presets (default, TypeScript, Router, Vuex, Linter). Presets store configuration in <code>package.json</code> for reuse. Vue CLI installs dependencies and sets up webpack, Babel, PostCSS, and optional features.</p>"},{"location":"vue-interview-roadmap/6.2-vue-cli-basics/#development-build","title":"Development &amp; Build","text":"<p><code>npm run serve</code> starts a dev server with hot module replacement, while <code>npm run build</code> outputs optimized bundles using webpack. Vue CLI exposes configuration via <code>vue.config.js</code>, allowing chainable webpack adjustments, dev server proxies, and environment variables through <code>.env</code> files.</p>"},{"location":"vue-interview-roadmap/6.2-vue-cli-basics/#plugin-ecosystem","title":"Plugin Ecosystem","text":"<p><code>vue add</code> installs official or community plugins that extend the webpack config (e.g., PWA, Apollo, ESLint). While Vue CLI is now in maintenance, understanding it helps maintain existing codebases and migrate to newer tooling like Vite.</p>"},{"location":"vue-interview-roadmap/6.2-vue-cli-basics/#code-example","title":"Code Example","text":"<pre><code>npm install -g @vue/cli\nvue create dashboard\ncd dashboard\nnpm run serve\n</code></pre>"},{"location":"vue-interview-roadmap/6.2-vue-cli-basics/#resources","title":"Resources","text":"<ul> <li>Vue CLI Documentation \u2013 official guide and configuration reference.</li> <li>Vue CLI 5 Release Notes \u2013 highlights current maintenance status.</li> <li>Vue Docs \u2013 Tooling Guide \u2013 compares Vue CLI with Vite and <code>create-vue</code>.</li> </ul>"},{"location":"vue-interview-roadmap/6.3-setup-function/","title":"6.3 What is the purpose of the setup() function in Vue 3?","text":""},{"location":"vue-interview-roadmap/6.3-setup-function/#quick-revision","title":"Quick Revision","text":"<ul> <li><code>setup()</code> is the entry point for the Composition API, running before component creation to initialize reactive state and logic.</li> <li>It receives <code>props</code> and <code>context</code> and must return values to expose them to the template.</li> <li>Inside <code>setup()</code>, you use Composition API features (<code>ref</code>, <code>reactive</code>, <code>computed</code>, lifecycle hooks) without <code>this</code>.</li> </ul>"},{"location":"vue-interview-roadmap/6.3-setup-function/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/6.3-setup-function/#execution-timing","title":"Execution Timing","text":"<p><code>setup()</code> executes before the component instance is created, so <code>this</code> is undefined. Props are reactive but read-only. The function can return an object (exposed to template) or a render function. <code>&lt;script setup&gt;</code> compiles to a <code>setup()</code> under the hood, automatically exposing top-level bindings.</p>"},{"location":"vue-interview-roadmap/6.3-setup-function/#arguments-context","title":"Arguments &amp; Context","text":"<p>The first argument is <code>props</code>, reactive but should not be destructured directly (use <code>toRefs</code>). The second argument is a context object with <code>attrs</code>, <code>slots</code>, and <code>emit</code>. <code>emit</code> replaces <code>$emit</code> for emitting events. <code>expose</code> allows customizing what refs are exposed to <code>ref</code> users.</p>"},{"location":"vue-interview-roadmap/6.3-setup-function/#logic-organization","title":"Logic Organization","text":"<p>Within <code>setup()</code>, you can call composables, register lifecycle hooks (<code>onMounted</code>, etc.), and create watchers. Returning state makes it accessible in the template; functions can be returned directly. This structure enables modular, testable code.</p>"},{"location":"vue-interview-roadmap/6.3-setup-function/#code-example","title":"Code Example","text":"<pre><code>&lt;script&gt;\nimport { ref, onMounted } from 'vue';\n\nexport default {\n  props: { start: { type: Number, default: 0 } },\n  setup(props, { emit }) {\n    const count = ref(props.start);\n\n    function increment() {\n      count.value++;\n      emit('update:count', count.value);\n    }\n\n    onMounted(() =&gt; console.log('Mounted with', count.value));\n\n    return { count, increment };\n  },\n};\n&lt;/script&gt;\n</code></pre>"},{"location":"vue-interview-roadmap/6.3-setup-function/#resources","title":"Resources","text":"<ul> <li>Vue.js Docs \u2013 Composition API setup \u2013 official reference for <code>setup</code> arguments and return values.</li> <li>Vue.js Docs \u2013 <code>&lt;script setup&gt;</code> \u2013 syntactic sugar transforming into <code>setup()</code>.</li> <li>Vue School \u2013 Understanding setup() \u2013 tutorial with practical patterns.</li> </ul>"},{"location":"vue-interview-roadmap/6.4-slots/","title":"6.4 Can you explain slots, scoped slots, and dynamic slots?","text":""},{"location":"vue-interview-roadmap/6.4-slots/#quick-revision","title":"Quick Revision","text":"<ul> <li>Slots let parent components inject content into child components; default slots cover the basic use case.</li> <li>Scoped slots pass data from child to parent via slot props, enabling render customization.</li> <li>Dynamic slots allow binding slot names dynamically (<code>v-slot:[name]</code>) for flexible layouts.</li> </ul>"},{"location":"vue-interview-roadmap/6.4-slots/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/6.4-slots/#default-named-slots","title":"Default &amp; Named Slots","text":"<p>A component declares <code>&lt;slot&gt;</code> (default) or <code>&lt;slot name=\"header\"&gt;</code>. Parents provide content using <code>&lt;template v-slot:header&gt;</code> or shorthand <code>#header</code>. Named slots enable multiple insertion points.</p>"},{"location":"vue-interview-roadmap/6.4-slots/#scoped-slots","title":"Scoped Slots","text":"<p>Scoped slots expose data from the child by adding props to the slot element (e.g., <code>&lt;slot name=\"row\" :item=\"item\"&gt;</code>). The parent receives the props via <code>v-slot:row=\"{ item }\"</code>. This is useful for tables, lists, and renderless components where the parent controls rendering.</p>"},{"location":"vue-interview-roadmap/6.4-slots/#dynamic-slots","title":"Dynamic Slots","text":"<p>Use <code>v-slot:[dynamicName]</code> to bind slot names computed at runtime. Combined with <code>&lt;component :is&gt;</code> or conditional layouts, dynamic slots allow customizing component sections without rewriting templates.</p>"},{"location":"vue-interview-roadmap/6.4-slots/#code-example","title":"Code Example","text":"<p><pre><code>&lt;!-- DataTable.vue --&gt;\n&lt;template&gt;\n  &lt;table&gt;\n    &lt;thead&gt;\n      &lt;slot name=\"head\"&gt;\n        &lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Email&lt;/th&gt;&lt;/tr&gt;\n      &lt;/slot&gt;\n    &lt;/thead&gt;\n    &lt;tbody&gt;\n      &lt;tr v-for=\"row in rows\" :key=\"row.id\"&gt;\n        &lt;slot name=\"row\" :row=\"row\"&gt;\n          &lt;td&gt;{{ row.name }}&lt;/td&gt;\n          &lt;td&gt;{{ row.email }}&lt;/td&gt;\n        &lt;/slot&gt;\n      &lt;/tr&gt;\n    &lt;/tbody&gt;\n  &lt;/table&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\ndefineProps({ rows: Array });\n&lt;/script&gt;\n</code></pre> <pre><code>&lt;!-- Parent --&gt;\n&lt;DataTable :rows=\"users\"&gt;\n  &lt;template #head&gt;\n    &lt;tr&gt;&lt;th&gt;User&lt;/th&gt;&lt;th&gt;Contact&lt;/th&gt;&lt;/tr&gt;\n  &lt;/template&gt;\n  &lt;template #row=\"{ row }\"&gt;\n    &lt;td&gt;{{ row.name.toUpperCase() }}&lt;/td&gt;\n    &lt;td&gt;&lt;a :href=\"`mailto:${row.email}`\"&gt;Email&lt;/a&gt;&lt;/td&gt;\n  &lt;/template&gt;\n&lt;/DataTable&gt;\n</code></pre></p>"},{"location":"vue-interview-roadmap/6.4-slots/#resources","title":"Resources","text":"<ul> <li>Vue.js Docs \u2013 Slots \u2013 comprehensive guide to default, named, and scoped slots.</li> <li>Vue.js Docs \u2013 Dynamic Slots \u2013 demonstrates <code>v-slot:[name]</code> syntax.</li> <li>Vue School \u2013 Renderless Components \u2013 practical use cases for scoped slots.</li> </ul>"},{"location":"vue-interview-roadmap/6.5-scoped-css/","title":"6.5 How does scoped CSS work in Vue?","text":""},{"location":"vue-interview-roadmap/6.5-scoped-css/#quick-revision","title":"Quick Revision","text":"<ul> <li><code>&lt;style scoped&gt;</code> in SFCs transforms selectors with unique data attributes to limit styles to the component.</li> <li>Scoped styles apply using attribute selectors (e.g., <code>[data-v-123abc]</code>), preserving component isolation.</li> <li>Use deep selectors (<code>::v-deep</code>) or global styles for styling child components and third-party libraries.</li> </ul>"},{"location":"vue-interview-roadmap/6.5-scoped-css/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/6.5-scoped-css/#compilation-process","title":"Compilation Process","text":"<p>When compiling an SFC with <code>&lt;style scoped&gt;</code>, Vue injects a unique attribute (e.g., <code>data-v-1a2b3c</code>) into the component\u2019s root and child elements. CSS selectors in the scoped block are rewritten to include that attribute, ensuring they target only elements in the component.</p>"},{"location":"vue-interview-roadmap/6.5-scoped-css/#working-with-child-components","title":"Working with Child Components","text":"<p>Scoped styles do not penetrate child components by default. To style child components, use the <code>::v-deep</code> combinator or global styles. For example, <code>::v-deep(.child)</code> applies to descendant components. Alternatively, create shared CSS modules or global stylesheets for consistent branding.</p>"},{"location":"vue-interview-roadmap/6.5-scoped-css/#considerations","title":"Considerations","text":"<p>Scoped CSS increases specificity but doesn\u2019t guarantee isolation from global resets. Use CSS modules (<code>&lt;style module&gt;</code>) for hashed class names or utility frameworks (Tailwind). Remember that scoped styles are still processed by PostCSS/Babel, so autoprefixing works.</p>"},{"location":"vue-interview-roadmap/6.5-scoped-css/#code-example","title":"Code Example","text":"<pre><code>&lt;template&gt;\n  &lt;div class=\"card\"&gt;\n    &lt;slot /&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n.card {\n  border: 1px solid #e5e7eb;\n  padding: 1rem;\n  border-radius: 8px;\n}\n&lt;/style&gt;\n</code></pre>"},{"location":"vue-interview-roadmap/6.5-scoped-css/#resources","title":"Resources","text":"<ul> <li>Vue.js Docs \u2013 Scoped CSS \u2013 explains attribute rewriting and deep selectors.</li> <li>Vue.js Docs \u2013 CSS Modules \u2013 alternative to scoped for module-based class names.</li> <li>Vue School \u2013 Scoped Styles \u2013 video lesson covering deep selectors and caveats.</li> </ul>"},{"location":"vue-interview-roadmap/6.6-teleport/","title":"6.6 What is Teleport in Vue 3 and when would you use it?","text":""},{"location":"vue-interview-roadmap/6.6-teleport/#quick-revision","title":"Quick Revision","text":"<ul> <li><code>Teleport</code> renders component content into a different part of the DOM while preserving reactivity.</li> <li>Use it for overlays, modals, tooltips, or portals that need to escape CSS/DOM hierarchy constraints.</li> <li>Teleported content still belongs to the Vue component tree, so props, events, and reactivity work normally.</li> </ul>"},{"location":"vue-interview-roadmap/6.6-teleport/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/6.6-teleport/#how-teleport-works","title":"How Teleport Works","text":"<p><code>&lt;Teleport to=\"#modal-root\"&gt;</code> moves its slot content to the target element elsewhere in the DOM. Vue keeps the component in the logical tree, so state and lifecycle behave as if it were inline, but the rendered DOM lives at the target location. The target can be any CSS selector or DOM node.</p>"},{"location":"vue-interview-roadmap/6.6-teleport/#use-cases","title":"Use Cases","text":"<p>Teleport solves z-index and overflow issues for modals or popovers by rendering them at the document root. It\u2019s also useful for rendering inside iframes or shadow DOM hosts. Because events bubble within Vue\u2019s virtual tree, you can emit events or access provide/inject normally.</p>"},{"location":"vue-interview-roadmap/6.6-teleport/#considerations","title":"Considerations","text":"<p>Ensure the target element exists before Teleport renders; create it in HTML or mount hook. Teleport supports conditional rendering and can disable teleporting with the <code>disabled</code> prop. When server-side rendering, ensure matching structure between server and client to avoid hydration issues.</p>"},{"location":"vue-interview-roadmap/6.6-teleport/#code-example","title":"Code Example","text":"<pre><code>&lt;template&gt;\n  &lt;Teleport to=\"#portal\"&gt;\n    &lt;div class=\"modal\" v-if=\"open\"&gt;\n      &lt;button @click=\"$emit('close')\"&gt;Close&lt;/button&gt;\n      &lt;slot /&gt;\n    &lt;/div&gt;\n  &lt;/Teleport&gt;\n&lt;/template&gt;\n</code></pre>"},{"location":"vue-interview-roadmap/6.6-teleport/#resources","title":"Resources","text":"<ul> <li>Vue.js Docs \u2013 Teleport \u2013 official description and usage guidelines.</li> <li>Vue Mastery \u2013 Using Teleport \u2013 practical scenarios and pitfalls.</li> <li>Vue.js Docs \u2013 SSR with Teleport \u2013 considerations for server rendering.</li> </ul>"},{"location":"vue-interview-roadmap/6.7-provide-inject/","title":"6.7 How does the Provide/Inject API work?","text":""},{"location":"vue-interview-roadmap/6.7-provide-inject/#quick-revision","title":"Quick Revision","text":"<ul> <li><code>provide</code> allows ancestor components to supply values; <code>inject</code> lets descendants access them without prop drilling.</li> <li>Values are reactive when provided as refs/reactives; primitives remain static unless wrapped.</li> <li>Use Provide/Inject for dependency injection patterns, plugin configuration, or global services.</li> </ul>"},{"location":"vue-interview-roadmap/6.7-provide-inject/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/6.7-provide-inject/#providing-values","title":"Providing Values","text":"<p>Call <code>provide(key, value)</code> inside <code>setup()</code> (or use the Options API\u2019s <code>provide</code> option) to register a value on the component instance. Keys can be strings or symbols. Provided values are available to all descendants, not just direct children.</p>"},{"location":"vue-interview-roadmap/6.7-provide-inject/#injecting-values","title":"Injecting Values","text":"<p>Descendant components call <code>inject(key, defaultValue)</code> to retrieve the provided value. If the provided value is reactive (ref or reactive object), the consumer sees updates. Injected values are read-only by convention; to allow mutation, provide methods or reactive state and document usage.</p>"},{"location":"vue-interview-roadmap/6.7-provide-inject/#use-cases-patterns","title":"Use Cases &amp; Patterns","text":"<p>Provide/Inject is great for theming, localization, or sharing service instances (e.g., a global event bus). It complements but does not replace Vuex/Pinia for large-scale state. Provide defaults when injection fails to keep components decoupled.</p>"},{"location":"vue-interview-roadmap/6.7-provide-inject/#code-example","title":"Code Example","text":"<p><pre><code>// Provider\nimport { provide, ref } from 'vue';\n\nconst theme = ref('light');\nprovide('theme', theme);\n</code></pre> <pre><code>// Consumer\nimport { inject } from 'vue';\n\nconst theme = inject('theme', 'light');\n</code></pre> Changing <code>theme.value</code> in the provider updates consumers automatically.</p>"},{"location":"vue-interview-roadmap/6.7-provide-inject/#resources","title":"Resources","text":"<ul> <li>Vue.js Docs \u2013 Provide/Inject \u2013 official patterns and caveats.</li> <li>VueUse \u2013 provideReactive \u2013 helper utilities for reactive injection.</li> <li>Vue School \u2013 Dependency Injection in Vue 3 \u2013 tutorial with common scenarios.</li> </ul>"},{"location":"vue-interview-roadmap/6.8-custom-directives/","title":"6.8 How can you create custom directives in Vue?","text":""},{"location":"vue-interview-roadmap/6.8-custom-directives/#quick-revision","title":"Quick Revision","text":"<ul> <li>Custom directives encapsulate low-level DOM manipulations outside component logic.</li> <li>Register directives globally with <code>app.directive</code> or locally via the <code>directives</code> option / <code>v-node</code> functions in Composition API.</li> <li>Directive hooks (<code>created</code>, <code>beforeMount</code>, <code>mounted</code>, <code>updated</code>, <code>unmounted</code>) mirror component lifecycle for DOM access.</li> </ul>"},{"location":"vue-interview-roadmap/6.8-custom-directives/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/6.8-custom-directives/#defining-directives","title":"Defining Directives","text":"<p>In Vue 3, a directive is an object with lifecycle hooks or a function shorthand for <code>mounted</code>/<code>updated</code>. Hooks receive the element, binding (<code>value</code>, <code>oldValue</code>, <code>arg</code>, <code>modifiers</code>), and vnode. Register globally in <code>main.js</code> with <code>app.directive('focus', { mounted(el) { el.focus(); } })</code> or locally in component options.</p>"},{"location":"vue-interview-roadmap/6.8-custom-directives/#use-cases","title":"Use Cases","text":"<p>Directives suit DOM behaviors such as autofocus, lazy loading, intersection observers, or third-party library integration. They keep components declarative while encapsulating imperative DOM work.</p>"},{"location":"vue-interview-roadmap/6.8-custom-directives/#composition-api-integration","title":"Composition API Integration","text":"<p>You can export directives and apply them with <code>v-my-directive</code>. Inside SFCs, use the <code>directives</code> option or register globally. Avoid using directives for logic that fits better as components or composables.</p>"},{"location":"vue-interview-roadmap/6.8-custom-directives/#code-example","title":"Code Example","text":"<p><pre><code>// focus.js\nexport const vFocus = {\n  mounted(el) {\n    el.focus();\n  },\n};\n</code></pre> <pre><code>// main.js\nimport { createApp } from 'vue';\nimport App from './App.vue';\nimport { vFocus } from './directives/focus';\n\ncreateApp(App).directive('focus', vFocus).mount('#app');\n</code></pre> <pre><code>&lt;input v-focus /&gt;\n</code></pre></p>"},{"location":"vue-interview-roadmap/6.8-custom-directives/#resources","title":"Resources","text":"<ul> <li>Vue.js Docs \u2013 Custom Directives \u2013 lifecycle hooks and examples.</li> <li>Vue School \u2013 Custom Directives Lesson \u2013 practical directive patterns.</li> <li>MDN \u2013 Intersection Observer API \u2013 often used in custom directives for lazy loading.</li> </ul>"},{"location":"vue-interview-roadmap/7.1-error-boundaries/","title":"7.1 How do you handle error boundaries in Vue?","text":""},{"location":"vue-interview-roadmap/7.1-error-boundaries/#quick-revision","title":"Quick Revision","text":"<ul> <li>Vue uses the <code>errorCaptured</code> hook (Options API) or <code>onErrorCaptured</code> (Composition API) to catch errors from child components.</li> <li>You can render fallback UI by returning <code>false</code> (prevent propagation) and setting local state.</li> <li>Global error handlers (<code>app.config.errorHandler</code>) capture uncaught errors for logging.</li> </ul>"},{"location":"vue-interview-roadmap/7.1-error-boundaries/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/7.1-error-boundaries/#component-level-error-capturing","title":"Component-Level Error Capturing","text":"<p><code>errorCaptured(err, instance, info)</code> fires when a descendant throws during render, lifecycle, or event handler. Returning <code>false</code> stops the error from bubbling further. Use this to swap in fallback UI or report telemetry. In Composition API, call <code>onErrorCaptured</code> inside <code>setup()</code>.</p>"},{"location":"vue-interview-roadmap/7.1-error-boundaries/#global-handlers","title":"Global Handlers","text":"<p>Set <code>app.config.errorHandler = (err, instance, info) =&gt; { ... }</code> to catch errors application-wide. Combine with logging services (Sentry) and display notifications. <code>app.config.warnHandler</code> can intercept warnings.</p>"},{"location":"vue-interview-roadmap/7.1-error-boundaries/#async-suspense","title":"Async &amp; Suspense","text":"<p>For async components and Suspense, rejection errors trigger <code>onErrorCaptured</code> or the fallback slot. Wrap potentially failing code in try/catch to provide user feedback.</p>"},{"location":"vue-interview-roadmap/7.1-error-boundaries/#code-example","title":"Code Example","text":"<pre><code>&lt;script setup&gt;\nimport { ref, onErrorCaptured } from 'vue';\n\nconst failed = ref(false);\n\nonErrorCaptured((err) =&gt; {\n  failed.value = true;\n  console.error('Child error', err);\n  return false; // prevent further propagation\n});\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div v-if=\"failed\"&gt;Something went wrong.&lt;/div&gt;\n  &lt;ChildComponent v-else /&gt;\n&lt;/template&gt;\n</code></pre>"},{"location":"vue-interview-roadmap/7.1-error-boundaries/#resources","title":"Resources","text":"<ul> <li>Vue.js Docs \u2013 Error Handling \u2013 explains <code>errorCaptured</code> and global handlers.</li> <li>Vue.js API \u2013 app.config.errorHandler \u2013 application-level error handling.</li> <li>Sentry Vue SDK \u2013 practical integration for logging captured errors.</li> </ul>"},{"location":"vue-interview-roadmap/7.2-vue-devtools/","title":"7.2 What tools does Vue DevTools provide for debugging?","text":""},{"location":"vue-interview-roadmap/7.2-vue-devtools/#quick-revision","title":"Quick Revision","text":"<ul> <li>Vue DevTools inspects component hierarchies, reactive state, events, and performance metrics.</li> <li>It offers timeline recording, Vuex/Pinia state inspection, and component re-render tracing.</li> <li>DevTools integrates with browser extensions or standalone Electron app for local development.</li> </ul>"},{"location":"vue-interview-roadmap/7.2-vue-devtools/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/7.2-vue-devtools/#component-inspector","title":"Component Inspector","text":"<p>The Components tab displays the tree with props, emitted events, and reactive state. You can edit state directly, trigger component re-rendering, and highlight elements in the DOM. It supports both Options and Composition API (showing refs/composables).</p>"},{"location":"vue-interview-roadmap/7.2-vue-devtools/#timeline-performance","title":"Timeline &amp; Performance","text":"<p>The Timeline records events such as component mounts, Vuex mutations, router navigations, and custom marks. You can analyze render duration and identify slow updates. The Performance tab (beta) helps detect unnecessary re-renders.</p>"},{"location":"vue-interview-roadmap/7.2-vue-devtools/#state-management-plugins","title":"State Management &amp; Plugins","text":"<p>Vue DevTools integrates with Vuex and Pinia, allowing time-travel debugging, mutation/action logs, and editing store state. Plugins can add custom inspectors (e.g., Apollo, Vue I18n). For SSR or remote debugging, use the standalone app or set up devtools for mobile via network connections.</p>"},{"location":"vue-interview-roadmap/7.2-vue-devtools/#code-example","title":"Code Example","text":"<pre><code># Install standalone devtools for remote debugging\nnpm install -g @vue/devtools\nvue-devtools\n</code></pre>"},{"location":"vue-interview-roadmap/7.2-vue-devtools/#resources","title":"Resources","text":"<ul> <li>Vue DevTools Documentation \u2013 official guide covering features and setup.</li> <li>Vue DevTools \u2013 Timeline Guide \u2013 using the timeline to profile apps.</li> <li>Pinia DevTools Integration \u2013 explains store inspection and debugging features.</li> </ul>"},{"location":"vue-interview-roadmap/7.3-testing-strategies/","title":"7.3 What are some common Vue testing strategies (unit testing, integration testing, snapshot testing)?","text":""},{"location":"vue-interview-roadmap/7.3-testing-strategies/#quick-revision","title":"Quick Revision","text":"<ul> <li>Unit tests isolate components/composables with tools like Vitest or Jest plus Vue Test Utils.</li> <li>Integration tests render multiple components or routes together to verify interactions and store/router integration.</li> <li>Snapshot tests capture rendered output for regression checks but should complement functional assertions.</li> </ul>"},{"location":"vue-interview-roadmap/7.3-testing-strategies/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/7.3-testing-strategies/#unit-testing","title":"Unit Testing","text":"<p>Use Vue Test Utils to mount components with stubbed dependencies. Test props, emitted events, computed properties, and DOM output. Vitest offers fast ESM-based runs; Jest is common in legacy setups. Mock HTTP requests and global services to isolate behavior.</p>"},{"location":"vue-interview-roadmap/7.3-testing-strategies/#integration-testing","title":"Integration Testing","text":"<p>Render components with their child dependencies, router, and store to verify flows like navigation or form submission. Cypress Component Testing or Playwright can render Vue components in a real browser for higher fidelity. Keep integration tests focused on critical paths to balance speed and coverage.</p>"},{"location":"vue-interview-roadmap/7.3-testing-strategies/#snapshot-testing","title":"Snapshot Testing","text":"<p>Snapshot tests compare the rendered markup against stored snapshots, catching unintended structural changes. Use sparingly and alongside targeted assertions to avoid brittle tests. Update snapshots intentionally when UI changes are expected.</p>"},{"location":"vue-interview-roadmap/7.3-testing-strategies/#code-example","title":"Code Example","text":"<pre><code>import { mount } from '@vue/test-utils';\nimport Counter from './Counter.vue';\n\ndescribe('Counter', () =&gt; {\n  it('increments on click', async () =&gt; {\n    const wrapper = mount(Counter);\n    await wrapper.find('button').trigger('click');\n    expect(wrapper.text()).toContain('1');\n  });\n});\n</code></pre>"},{"location":"vue-interview-roadmap/7.3-testing-strategies/#resources","title":"Resources","text":"<ul> <li>Vue Test Utils Documentation \u2013 API for mounting and asserting Vue components.</li> <li>Vitest Guide \u2013 Testing Vue \u2013 configuration for Vue + Vitest.</li> <li>Cypress Component Testing \u2013 running Vue components in Cypress for integration tests.</li> </ul>"},{"location":"vue-interview-roadmap/8.1-transitions/","title":"8.1 How do Vue transitions and animations work?","text":""},{"location":"vue-interview-roadmap/8.1-transitions/#quick-revision","title":"Quick Revision","text":"<ul> <li>Vue provides <code>&lt;Transition&gt;</code> and <code>&lt;TransitionGroup&gt;</code> components to apply CSS transitions/animations when elements enter/leave.</li> <li>Transition hooks add/remove CSS classes (<code>*-enter</code>, <code>*-enter-active</code>, etc.) that you style with CSS or animate via JS hooks.</li> <li>Use TransitionGroup for list animations and integrate with libraries like GSAP for advanced effects.</li> </ul>"},{"location":"vue-interview-roadmap/8.1-transitions/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/8.1-transitions/#transition-component","title":"Transition Component","text":"<p>Wrap a single element or component in <code>&lt;Transition name=\"fade\"&gt;</code>. Vue automatically toggles classes (<code>fade-enter-from</code>, <code>fade-enter-active</code>, <code>fade-leave-to</code>) during enter/leave. You define CSS for these classes to control opacity, transforms, or other properties. <code>appear</code> enables initial render animations.</p>"},{"location":"vue-interview-roadmap/8.1-transitions/#transition-hooks","title":"Transition Hooks","text":"<p>Transition components expose JS hooks (<code>onBeforeEnter</code>, <code>onEnter</code>, <code>onAfterLeave</code>) for manual control or integrating with JS animation libraries. Provide <code>done</code> callback to signal completion when using asynchronous animations.</p>"},{"location":"vue-interview-roadmap/8.1-transitions/#transitiongroup","title":"TransitionGroup","text":"<p><code>&lt;TransitionGroup&gt;</code> handles lists by tracking elements via keys, applying move transitions using the <code>*-move</code> class. It wraps elements in a <code>span</code> by default; use <code>tag</code> prop to change the wrapper.</p>"},{"location":"vue-interview-roadmap/8.1-transitions/#code-example","title":"Code Example","text":"<pre><code>&lt;template&gt;\n  &lt;button @click=\"show = !show\"&gt;Toggle&lt;/button&gt;\n  &lt;Transition name=\"fade\"&gt;\n    &lt;p v-if=\"show\" class=\"message\"&gt;Hello Vue!&lt;/p&gt;\n  &lt;/Transition&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { ref } from 'vue';\nconst show = ref(true);\n&lt;/script&gt;\n\n&lt;style scoped&gt;\n.fade-enter-active, .fade-leave-active {\n  transition: opacity 0.3s ease;\n}\n.fade-enter-from, .fade-leave-to {\n  opacity: 0;\n}\n&lt;/style&gt;\n</code></pre>"},{"location":"vue-interview-roadmap/8.1-transitions/#resources","title":"Resources","text":"<ul> <li>Vue.js Docs \u2013 Transition Basics \u2013 explains CSS class hooks and appear transitions.</li> <li>Vue.js Docs \u2013 TransitionGroup \u2013 list animations and move transitions.</li> <li>GSAP + Vue Guide \u2013 using GSAP with Vue transitions.</li> </ul>"},{"location":"vue-interview-roadmap/9.1-virtual-dom/","title":"9.1 How does Vue handle DOM updates with its virtual DOM?","text":""},{"location":"vue-interview-roadmap/9.1-virtual-dom/#quick-revision","title":"Quick Revision","text":"<ul> <li>Vue compiles templates into render functions that produce virtual DOM (VNode) trees.</li> <li>When reactive state changes, Vue diffs the new VNode tree against the previous tree to compute minimal DOM patches.</li> <li>Vue\u2019s compiler generates optimized blocks and patch flags to skip static sections and accelerate updates.</li> </ul>"},{"location":"vue-interview-roadmap/9.1-virtual-dom/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/9.1-virtual-dom/#virtual-dom-rendering","title":"Virtual DOM Rendering","text":"<p>Templates compile to <code>render</code> functions returning VNodes (<code>h(type, props, children)</code>). On initial render, Vue converts VNodes to real DOM. Subsequent renders generate new VNodes which are diffed against the old ones.</p>"},{"location":"vue-interview-roadmap/9.1-virtual-dom/#diffing-algorithm","title":"Diffing Algorithm","text":"<p>Vue uses a fast, optimized diffing algorithm with heuristics. It compares nodes by type and key, reusing DOM elements where possible. For lists, keys guide reordering via longest increasing subsequence (LIS) to minimize moves. Patch flags annotate dynamic parts (e.g., text, class) so Vue only updates what changed.</p>"},{"location":"vue-interview-roadmap/9.1-virtual-dom/#compiler-optimizations","title":"Compiler Optimizations","text":"<p>Vue 3\u2019s compiler detects static nodes and hoists them out of render functions, marking dynamic nodes with patch flags (e.g., <code>TEXT</code>, <code>CLASS</code>). Block tree tracking groups dynamic children for targeted updates, reducing diff cost. Fragments allow multiple root nodes without extra wrappers.</p>"},{"location":"vue-interview-roadmap/9.1-virtual-dom/#code-example","title":"Code Example","text":"<p><pre><code>import { h, ref } from 'vue';\n\nexport default {\n  setup() {\n    const count = ref(0);\n    return () =&gt; h('button', { onClick: () =&gt; count.value++ }, `Count: ${count.value}`);\n  },\n};\n</code></pre> This render function creates a VNode for the button each render; Vue updates only the text content when <code>count</code> changes.</p>"},{"location":"vue-interview-roadmap/9.1-virtual-dom/#resources","title":"Resources","text":"<ul> <li>Vue.js Docs \u2013 Rendering Mechanism \u2013 explains virtual DOM and patching.</li> <li>Vue.js Docs \u2013 Template Compilation \u2013 shows how templates become render functions.</li> <li>Vue 3 Source \u2013 Renderer \u2013 implementation of the patch algorithm and block tree optimizations.</li> </ul>"},{"location":"vue-interview-roadmap/9.2-performance-optimization/","title":"9.2 What are some techniques for performance optimization in Vue apps?","text":""},{"location":"vue-interview-roadmap/9.2-performance-optimization/#quick-revision","title":"Quick Revision","text":"<ul> <li>Optimize rendering with computed properties, memoization, and avoiding unnecessary reactive dependencies.</li> <li>Use lazy loading (async components, route-level code splitting) and tree-shaking to reduce bundle size.</li> <li>Employ caching (<code>keep-alive</code>), virtualization, and performance profiling to handle heavy UI interactions.</li> </ul>"},{"location":"vue-interview-roadmap/9.2-performance-optimization/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/9.2-performance-optimization/#rendering-optimizations","title":"Rendering Optimizations","text":"<p>Avoid expensive computations inside templates; use computed props. Limit reactive dependencies by destructuring with <code>toRefs</code> and splitting components to reduce re-render scope. Use <code>v-memo</code> (Vue 3.3+) or <code>shallowRef</code> for large objects. Leverage <code>defineComponent({ inheritAttrs: false })</code> to avoid attribute updates when unnecessary.</p>"},{"location":"vue-interview-roadmap/9.2-performance-optimization/#network-bundle","title":"Network &amp; Bundle","text":"<p>Implement code splitting with dynamic imports and <code>defineAsyncComponent</code>. Tree-shake unused components by using ES module imports. Compress assets, enable HTTP/2, and leverage CDN caching. Use <code>preload</code>/<code>prefetch</code> for critical resources.</p>"},{"location":"vue-interview-roadmap/9.2-performance-optimization/#ui-techniques","title":"UI Techniques","text":"<p><code>&lt;KeepAlive&gt;</code> caches component instances between route/tab switches. Virtualize long lists with libraries like Vue Virtual Scroll List. Debounce expensive watchers, throttle scroll handlers, and use <code>requestAnimationFrame</code> for smooth animations. Profile using browser devtools and Vue DevTools performance timeline.</p>"},{"location":"vue-interview-roadmap/9.2-performance-optimization/#code-example","title":"Code Example","text":"<p><pre><code>&lt;KeepAlive include=\"Dashboard\"&gt;\n  &lt;component :is=\"currentView\" /&gt;\n&lt;/KeepAlive&gt;\n</code></pre> Caching the <code>Dashboard</code> component avoids re-fetching data each time the user navigates back.</p>"},{"location":"vue-interview-roadmap/9.2-performance-optimization/#resources","title":"Resources","text":"<ul> <li>Vue.js Docs \u2013 Performance \u2013 official performance checklist.</li> <li>Vue.js Docs \u2013 KeepAlive \u2013 caching component instances.</li> <li>VueUse \u2013 useVirtualList \u2013 helper for list virtualization.</li> </ul>"},{"location":"vue-interview-roadmap/9.3-memory-leaks/","title":"9.3 What are common memory leaks in Vue and how do you avoid them?","text":""},{"location":"vue-interview-roadmap/9.3-memory-leaks/#quick-revision","title":"Quick Revision","text":"<ul> <li>Memory leaks often stem from lingering event listeners, timers, or subscriptions not cleaned up on unmount.</li> <li>Use lifecycle hooks (<code>onBeforeUnmount</code>) to remove listeners, cancel requests, and clear intervals.</li> <li>Watch for detached DOM nodes from third-party libraries and leverage weak references or plugin teardown APIs.</li> </ul>"},{"location":"vue-interview-roadmap/9.3-memory-leaks/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"vue-interview-roadmap/9.3-memory-leaks/#sources-of-leaks","title":"Sources of Leaks","text":"<p>Components that attach global event listeners (<code>window</code>, <code>document</code>), websockets, or intervals can leak if not removed during teardown. Third-party libraries that imperatively manipulate the DOM may leave detached nodes. Retained references in closures can also prevent garbage collection.</p>"},{"location":"vue-interview-roadmap/9.3-memory-leaks/#prevention","title":"Prevention","text":"<p>Use <code>onBeforeUnmount</code>/<code>onUnmounted</code> to clean up listeners and timers. Wrap external subscriptions in composables that manage cleanup. For watchers, stop them manually with the returned stop handle when no longer needed. Avoid storing DOM elements or component instances in long-lived singletons.</p>"},{"location":"vue-interview-roadmap/9.3-memory-leaks/#diagnostics","title":"Diagnostics","text":"<p>Use browser memory profiles and heap snapshots to track retained objects. Vue DevTools performance timeline can reveal components not being destroyed. Tools like <code>why-did-you-render</code> alternatives or manual logging help detect repeated mount/unmount cycles without cleanup.</p>"},{"location":"vue-interview-roadmap/9.3-memory-leaks/#code-example","title":"Code Example","text":"<pre><code>import { onMounted, onBeforeUnmount } from 'vue';\n\nonMounted(() =&gt; {\n  window.addEventListener('resize', handler);\n});\n\nonBeforeUnmount(() =&gt; {\n  window.removeEventListener('resize', handler);\n});\n</code></pre>"},{"location":"vue-interview-roadmap/9.3-memory-leaks/#resources","title":"Resources","text":"<ul> <li>Vue.js Docs \u2013 Performance: Avoid Memory Leaks \u2013 official guidance on cleanup.</li> <li>MDN \u2013 Memory Management \u2013 fundamentals of garbage collection and leaks.</li> <li>Vue School \u2013 Preventing Memory Leaks \u2013 examples of common pitfalls.</li> </ul>"}]}